<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width"><link rel="canonical" href="https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/"><style> html { position: relative; min-height: 100%; }</style><script type="text/javascript" async="" src="The%20Definitive%20Guide%20to%20Linux%20System%20Calls%20-%20Packagecloud%20Blog_files/mixpanel-2-latest.js"></script><script async="" src="The%20Definitive%20Guide%20to%20Linux%20System%20Calls%20-%20Packagecloud%20Blog_files/analytics.js"></script><script type="text/javascript"> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-49973003-2', 'auto'); ga('send', 'pageview'); </script> <script type="text/javascript">(function(e,a){if(!a.__SV){var b=window;try{var c,l,i,j=b.location,g=j.hash;c=function(a,b){return(l=a.match(RegExp(b+"=([^&]*)")))?l[1]:null};g&&c(g,"state")&&(i=JSON.parse(decodeURIComponent(c(g,"state"))),"mpeditor"===i.action&&(b.sessionStorage.setItem("_mpcehash",g),history.replaceState(i.desiredHash||"",e.title,j.pathname+j.search)))}catch(m){}var k,h;window.mixpanel=a;a._i=[];a.init=function(b,c,f){function e(b,a){var c=a.split(".");2==c.length&&(b=b[c[0]],a=c[1]);b[a]=function(){b.push([a].concat(Array.prototype.slice.call(arguments, 0)))}}var d=a;"undefined"!==typeof f?d=a[f]=[]:f="mixpanel";d.people=d.people||[];d.toString=function(b){var a="mixpanel";"mixpanel"!==f&&(a+="."+f);b||(a+=" (stub)");return a};d.people.toString=function(){return d.toString(1)+".people (stub)"};k="disable time_event track track_pageview track_links track_forms register register_once alias unregister identify name_tag set_config reset people.set people.set_once people.increment people.append people.union people.track_charge people.clear_charges people.delete_user".split(" "); for(h=0;h<k.length;h++)e(d,k[h]);a._i.push([b,c,f])};a.__SV=1.2;b=e.createElement("script");b.type="text/javascript";b.async=!0;b.src="undefined"!==typeof MIXPANEL_CUSTOM_LIB_URL?MIXPANEL_CUSTOM_LIB_URL:"file:"===e.location.protocol&&"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js".match(/^\/\//)?"https://cdn.mxpnl.com/libs/mixpanel-2-latest.min.js":"//cdn.mxpnl.com/libs/mixpanel-2-latest.min.js";c=e.getElementsByTagName("script")[0];c.parentNode.insertBefore(b,c)}})(document,window.mixpanel||[]); mixpanel.init("aa1b8da0e28ec2c1a0a8703cd9fe2fe0"); mixpanel.track( "View Blog", {"url": "/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/"} ); mixpanel.register_once({ 'first_seenn': new Date().toISOString() }); mixpanel.register({ 'last_seen': new Date().toISOString() }); mixpanel.people.increment('blog_articles_viewed'); mixpanel.people.union('articles_read', "The Definitive Guide to Linux System Calls"); mixpanel.track_forms('#mc-embedded-subscribe-form-top', 'Newsletter Signup', {"position": "top", "source": "blog"}); mixpanel.track_forms('#mc-embedded-subscribe-form-slidein', 'Newsletter Signup', {"position": "slidein", "source": "blog"}); </script><title>The Definitive Guide to Linux System Calls - Packagecloud Blog</title><meta property="og:title" content="The Definitive Guide to Linux System Calls"><meta name="author" content="packagecloud"><meta property="og:locale" content="en_US"><meta name="description" content="TL;DR This blog post explains how Linux programs call functions in the Linux kernel. It will outline several different methods of making systems calls, how to handcraft your own assembly to make system calls (examples included), kernel entry points into system calls, kernel exit points from system calls, glibc wrappers, bugs, and much, much more."><meta property="og:description" content="TL;DR This blog post explains how Linux programs call functions in the Linux kernel. It will outline several different methods of making systems calls, how to handcraft your own assembly to make system calls (examples included), kernel entry points into system calls, kernel exit points from system calls, glibc wrappers, bugs, and much, much more."><link rel="canonical" href="https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/"><meta property="og:url" content="https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/"><meta property="og:site_name" content="Packagecloud Blog"><meta property="og:type" content="article"><meta property="article:published_time" content="2016-04-05T03:30:00-07:00"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@packagecloudio"><meta name="twitter:creator" content="@packagecloud"> <script type="application/ld+json"> {"name":null,"description":"TL;DR This blog post explains how Linux programs call functions in the Linux kernel. It will outline several different methods of making systems calls, how to handcraft your own assembly to make system calls (examples included), kernel entry points into system calls, kernel exit points from system calls, glibc wrappers, bugs, and much, much more.","author":{"@type":"Person","name":"packagecloud"},"@type":"BlogPosting","url":"https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/","publisher":null,"image":null,"headline":"The Definitive Guide to Linux System Calls","dateModified":"2016-04-05T03:30:00-07:00","datePublished":"2016-04-05T03:30:00-07:00","sameAs":null,"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/"},"@context":"http://schema.org"}</script><link type="application/atom+xml" rel="alternate" href="https://blog.packagecloud.io/feed.xml" title="Packagecloud Blog">  </head><body><div class="navbar navbar-default navbar-top"><div class="container"><div class="row"><div class="col-md-4 navbar-header"> <a href="https://packagecloud.io/?utm_campaign=cmkt&amp;utm_medium=header&amp;utm_source=/eng/2016/04/05/the-definitive-guide-to-linux-system-calls" class="navbar-brand"><span class="glyphicon glyphicon-cloud"></span><span class="package">package</span><span class="cloud">cloud</span></a><a href="https://blog.packagecloud.io/" class="navbar-brand"><span class="cloud">:blog</span></a></div><div class="col-md-8 header-callout"> <script type="text/javascript"> mixpanel.track('Newsletter Impression', {"position": "top", "source": "blog"}) </script><div class="newsletter-callout fixed-bottom-right slidein-from-bottom"> <button class="close">close</button><h2>Never miss an update!</h2><div id="mc_embed_signup"> <form action="//packagecloud.us11.list-manage.com/subscribe/post?u=b115c1c550228aef6706f11e0&amp;id=3e91296be1" method="post" id="mc-embedded-subscribe-form-top" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate=""><div class="container" id="mc_embed_signup_scroll"><div class="row mc-field-group"><div class="subscribe-elements"> <input name="EMAIL" class="required email" id="mce-EMAIL" placeholder="Subscribe to our blog via email" type="email"> <input value="Sign up!" name="subscribe" id="mc-embedded-subscribe" class="btn btn-primary anim-btn" type="submit"></div></div><div id="mce-responses" class="clear"><div class="response" id="mce-error-response" style="display:none"></div><div class="response" id="mce-success-response" style="display:none"></div></div><div style="position: absolute; left: -5000px;"> <input name="b_b115c1c550228aef6706f11e0_1647acac08" tabindex="-1" type="text"></div></div></form><div class="reader-img"> <a href="http://feeds.feedburner.com/PackagecloudBlog" class="btn btn-primary" rel="alternate" type="application/rss+xml" target="_blank">Subscribe to our RSS feed</a> <label for="remember">Already signed up?</label> <input id="remember" name="remember" value="" type="checkbox"></div></div></div></div></div></div></div><div class="main-content container"><div class="row"><div class="col-md-12"><nav> <a class="back-to-top-fixed show" href="#">back to top</a> <a class="back-to-posts-link" href="https://blog.packagecloud.io/">back to posts</a></nav><section><div class="post"><header class="post-header"><h1>The Definitive Guide to Linux System Calls</h1><p class="meta">Apr 5, 2016 • packagecloud</p></header><div class="tags" id="tags"><h4>Tags:</h4><ul><li class="inline archive_list"><a class="tag_list_link" href="https://blog.packagecloud.io/tag/linux">linux</a></li></ul></div><article class="post-content type-system-sans"><h1 id="tldr">TL;DR</h1><p>This blog post explains how Linux programs call functions in the Linux kernel.</p><p>It
 will outline several different methods of making systems calls, how to 
handcraft your own assembly to make system calls (examples included), 
kernel entry points into system calls, kernel exit points from system 
calls, glibc wrappers, bugs, and much, much more. </p><div class="button-container callout"><div class="large-link-container"> <a href="https://packagecloud.io/?utm_campaign=cmkt&amp;utm_medium=callout&amp;utm_source=/eng/2016/04/05/the-definitive-guide-to-linux-system-calls&amp;utm_term=Create%20a%20package%20repository%20in%20less%20than%2010%20seconds,%20free." id="signup-banner-link"></a></div><p>Create a package repository in less than 10 seconds, free.</p><div class="sign-up-button" data-landing-page="/" data-callout-text="Create a package repository in less than 10 seconds, free." data-source="/eng/2016/04/05/the-definitive-guide-to-linux-system-calls"> <a href="https://packagecloud.io/?utm_campaign=cmkt&amp;utm_medium=callout&amp;utm_source=/eng/2016/04/05/the-definitive-guide-to-linux-system-calls&amp;utm_term=Create%20a%20package%20repository%20in%20less%20than%2010%20seconds,%20free." id="signup-banner-link"> <button class="anim-btn btn btn-primary btn-default">Sign up!</button> </a></div></div><ul id="markdown-toc"><li><a href="#tldr" id="markdown-toc-tldr">TL;DR</a></li><li><a href="#what-is-a-system-call" id="markdown-toc-what-is-a-system-call">What is a system call?</a></li><li><a href="#prerequisite-information" id="markdown-toc-prerequisite-information">Prerequisite information</a><ul><li><a href="#hardware-and-software" id="markdown-toc-hardware-and-software">Hardware and software</a></li><li><a href="#user-programs-the-kernel-and-cpu-privilege-levels" id="markdown-toc-user-programs-the-kernel-and-cpu-privilege-levels">User programs, the kernel, and CPU privilege levels</a></li><li><a href="#interrupts" id="markdown-toc-interrupts">Interrupts</a></li><li><a href="#model-specific-registers-msrs" id="markdown-toc-model-specific-registers-msrs">Model Specific Registers (MSRs)</a></li><li><a href="#calling-system-calls-with-assembly-is-a-bad-idea" id="markdown-toc-calling-system-calls-with-assembly-is-a-bad-idea">Calling system calls with assembly is a bad idea</a></li></ul></li><li><a href="#legacy-system-calls" id="markdown-toc-legacy-system-calls">Legacy system calls</a><ul><li><a href="#using-legacy-system-calls-with-your-own-assembly" id="markdown-toc-using-legacy-system-calls-with-your-own-assembly">Using legacy system calls with your own assembly</a></li><li><a href="#kernel-side-int-0x80-entry-point" id="markdown-toc-kernel-side-int-0x80-entry-point">Kernel-side: <code class="highlighter-rouge">int $0x80</code> entry point</a></li><li><a href="#returning-from-a-legacy-system-call-with-iret" id="markdown-toc-returning-from-a-legacy-system-call-with-iret">Returning from a legacy system call with <code class="highlighter-rouge">iret</code></a></li></ul></li><li><a href="#fast-system-calls" id="markdown-toc-fast-system-calls">Fast system calls</a><ul><li><a href="#32-bit-fast-system-calls" id="markdown-toc-32-bit-fast-system-calls">32-bit fast system calls</a><ul><li><a href="#sysentersysexit" id="markdown-toc-sysentersysexit"><code class="highlighter-rouge">sysenter</code>/<code class="highlighter-rouge">sysexit</code></a></li><li><a href="#__kernel_vsyscall-internals" id="markdown-toc-__kernel_vsyscall-internals"><code class="highlighter-rouge">__kernel_vsyscall</code> internals</a></li><li><a href="#using-sysenter-system-calls-with-your-own-assembly" id="markdown-toc-using-sysenter-system-calls-with-your-own-assembly">Using <code class="highlighter-rouge">sysenter</code> system calls with your own assembly</a></li><li><a href="#kernel-side-sysenter-entry-point" id="markdown-toc-kernel-side-sysenter-entry-point">Kernel-side: <code class="highlighter-rouge">sysenter</code> entry point</a></li><li><a href="#returning-from-a-sysenter-system-call-with-sysexit" id="markdown-toc-returning-from-a-sysenter-system-call-with-sysexit">Returning from a <code class="highlighter-rouge">sysenter</code> system call with <code class="highlighter-rouge">sysexit</code></a></li></ul></li><li><a href="#64-bit-fast-system-calls" id="markdown-toc-64-bit-fast-system-calls">64-bit fast system calls</a><ul><li><a href="#syscallsysret" id="markdown-toc-syscallsysret"><code class="highlighter-rouge">syscall</code>/<code class="highlighter-rouge">sysret</code></a></li><li><a href="#using-syscall-system-calls-with-your-own-assembly" id="markdown-toc-using-syscall-system-calls-with-your-own-assembly">Using <code class="highlighter-rouge">syscall</code> system calls with your own assembly</a></li><li><a href="#kernel-side-syscall-entry-point" id="markdown-toc-kernel-side-syscall-entry-point">Kernel-side: syscall entry point</a></li><li><a href="#returning-from-a-syscall-system-call-with-sysret" id="markdown-toc-returning-from-a-syscall-system-call-with-sysret">Returning from a <code class="highlighter-rouge">syscall</code> system call with <code class="highlighter-rouge">sysret</code></a></li></ul></li></ul></li><li><a href="#calling-a-syscall-semi-manually-with-syscall2" id="markdown-toc-calling-a-syscall-semi-manually-with-syscall2">Calling a syscall semi-manually with syscall(2)</a><ul><li><a href="#glibc-syscall-wrapper-internals" id="markdown-toc-glibc-syscall-wrapper-internals">glibc <code class="highlighter-rouge">syscall</code> wrapper internals</a></li></ul></li><li><a href="#virtual-system-calls" id="markdown-toc-virtual-system-calls">Virtual system calls</a><ul><li><a href="#vdso-in-the-kernel" id="markdown-toc-vdso-in-the-kernel">vDSO in the kernel</a></li><li><a href="#locating-the-vdso-in-memory" id="markdown-toc-locating-the-vdso-in-memory">Locating the vDSO in memory</a></li><li><a href="#vdso-in-glibc" id="markdown-toc-vdso-in-glibc">vDSO in glibc</a></li></ul></li><li><a href="#glibc-system-call-wrappers" id="markdown-toc-glibc-system-call-wrappers"><code class="highlighter-rouge">glibc</code> system call wrappers</a></li><li><a href="#interesting-syscall-related-bugs" id="markdown-toc-interesting-syscall-related-bugs">Interesting syscall related bugs</a><ul><li><a href="#cve-2010-3301" id="markdown-toc-cve-2010-3301">CVE-2010-3301</a></li><li><a href="#android-sysenter-abi-breakage" id="markdown-toc-android-sysenter-abi-breakage">Android <code class="highlighter-rouge">sysenter</code> ABI breakage</a></li></ul></li><li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a></li><li><a href="#related-posts" id="markdown-toc-related-posts">Related Posts</a></li></ul><h1 id="what-is-a-system-call">What is a system call?</h1><p>When you run a program which calls <code class="highlighter-rouge">open</code>, <code class="highlighter-rouge">fork</code>, <code class="highlighter-rouge">read</code>, <code class="highlighter-rouge">write</code> (and many others) you are making a system call.</p><p>System
 calls are how a program enters the kernel to perform some task. 
Programs use system calls to perform a variety of operations such as: 
creating processes, doing network and file IO, and much more.</p><p>You can find a list of system calls by checking the <a href="http://man7.org/linux/man-pages/man2/syscalls.2.html">man page for syscalls(2)</a>.</p><p>There
 are several different ways for user programs to make system calls and 
the low-level instructions for making a system call vary among CPU 
architectures.</p><p>As an application developer, you don’t typically 
need to think about how exactly a system call is made. You simply 
include the appropriate header file and make the call as if it were a 
normal function.</p><p><code class="highlighter-rouge">glibc</code> 
provides wrapper code which abstracts you away from the underlying code 
which arranges the arguments you’ve passed and enters the kernel.</p><p>Before
 we can dive into the details of how system calls are made, we’ll need 
to define some terms and examine some core ideas that will appear later.</p><h1 id="prerequisite-information">Prerequisite information</h1><h2 id="hardware-and-software">Hardware and software</h2><p>This blog post makes the following assumptions that:</p><ul><li>You
 are using a 32-bit or 64-bit Intel or AMD CPU. The discussion about the
 methods may be useful for people using other systems, but the code 
samples below contain CPU-specific code.</li><li>You are interested in 
the Linux kernel, version 3.13.0. Other kernel versions will be similar,
 but the exact line numbers, organization of code, and file paths will 
vary. Links to the 3.13.0 kernel source tree on GitHub are provided.</li><li>You are interested in <code class="highlighter-rouge">glibc</code> or <code class="highlighter-rouge">glibc</code> derived libc implementations (e.g., <code class="highlighter-rouge">eglibc</code>).</li></ul><p>x86-64 in this blog post will refer to 64bit Intel and AMD CPUs that are based on the x86 architecture.</p><h2 id="user-programs-the-kernel-and-cpu-privilege-levels">User programs, the kernel, and CPU privilege levels</h2><p>User
 programs (like your editor, terminal, ssh daemon, etc) need to interact
 with the Linux kernel so that the kernel can perform a set of 
operations on behalf of your user programs that they can’t perform 
themselves.</p><p>For example, if a user program needs to do some sort of IO (<code class="highlighter-rouge">open</code>, <code class="highlighter-rouge">read</code>, <code class="highlighter-rouge">write</code>, etc) or modify its address space (<code class="highlighter-rouge">mmap</code>, <code class="highlighter-rouge">sbrk</code>, etc) it must trigger the kernel to run to complete those actions on its behalf.</p><p>What prevents user programs from performing these actions themselves?</p><p>It turns out that the x86-64 CPUs have a concept called <a href="https://en.wikipedia.org/wiki/Privilege_level">privilege levels</a>.
 Privilege levels are a complex topic suitable for their own blog post. 
For the purposes of this post, we can (greatly) simplify the concept of 
privilege levels by saying:</p><ol><li>Privilege levels are a means of 
access control. The current privilege level determines which CPU 
instructions and IO may be performed.</li><li>The kernel runs at the most privileged level, called “Ring 0”. User programs run at a lesser level, typically “Ring 3”.</li></ol><p>In
 order for a user program to perform some privileged operation, it must 
cause a privilege level change (from “Ring 3” to “Ring 0”) so that the 
kernel can execute.</p><p>There are several ways to cause a privilege level change and trigger the kernel to perform some action.</p><p>Let’s start with a common way to cause the kernel to execute: interrupts.</p><h2 id="interrupts">Interrupts</h2><p>You can think of an interrupt as an event that is generated (or “raised”) by hardware or software.</p><p>A
 hardware interrupt is raised by a hardware device to notify the kernel 
that a particular event has occurred. A common example of this type of 
interrupt is an interrupt generated when a NIC receives a packet.</p><p>A
 software interrupt is raised by executing a piece of code. On x86-64 
systems, a software interrupt can be raised by executing the <code class="highlighter-rouge">int</code> instruction.</p><p>Interrupts usually have numbers assigned to them. Some of these interrupt numbers have a special meaning.</p><p>You
 can imagine an array that lives in memory on the CPU. Each entry in 
this array maps to an interrupt number. Each entry contains the address 
of a function that the CPU will begin executing when that interrupt is 
received along with some options, like what privilege level the 
interrupt handler function should be executed in.</p><p>Here’s a photo from the Intel CPU manual showing the layout of an entry in this array:</p><p><img src="The%20Definitive%20Guide%20to%20Linux%20System%20Calls%20-%20Packagecloud%20Blog_files/idt.png" alt="Screenshot of Interrupt Descriptor Table entry diagram for x86_64 CPUs"></p><p>If
 you look closely at the diagram, you can see a 2-bit field labeled DPL 
(Descriptor Privilege Level). The value in this field determines the 
minimum privilege level the CPU will be in when the handler function is 
executed.</p><p>This is how the CPU knows which address it should 
execute when a particular type of event is received and what privilege 
level the handler for that event should execute in.</p><p>In practice, 
there are lots of different ways to deal with interrupts on x86-64 
systems. If you are interested in learning more read about the <a href="http://wiki.osdev.org/8259_PIC">8259 Programmable Interrupt Controller</a>, <a href="http://wiki.osdev.org/APIC">Advanced Interrupt Controllers</a>, and <a href="http://wiki.osdev.org/IOAPIC">IO Advanced Interrupt Controllers</a>.</p><p>There
 are other complexities involved with dealing with both hardware and 
software interrupts, such as interrupt number collisions and remapping.</p><p>We don’t need to concern ourselves with these details for this discussion about system calls.</p><h2 id="model-specific-registers-msrs">Model Specific Registers (MSRs)</h2><p>Model
 Specific Registers (also known as MSRs) are control registers that have
 a specific purpose to control certain features of the CPU. The CPU 
documentation lists the addresses of each of the MSRs.</p><p>You can use the CPU instructions <code class="highlighter-rouge">rdmsr</code> to <code class="highlighter-rouge">wrmsr</code> to read and write MSRs, respectively.</p><p>There are also command line tools which allow you to read and write MSRs, but doing this is <em>not recommended</em> as changing these values (especially while a system is running) is dangerous unless you are really careful.</p><p>If
 you don’t mind potentially destabilizing your system or irreversibly 
corrupting your data, you can read and write MSRs by installing <code class="highlighter-rouge">msr-tools</code> and loading the <code class="highlighter-rouge">msr</code> kernel module:</p><figure class="highlight"><pre><code class="language-sh" data-lang="sh">% <span class="nb">sudo </span>apt-get install msr-tools
% <span class="nb">sudo </span>modprobe msr
% <span class="nb">sudo </span>rdmsr</code></pre></figure><p>Some of the system call methods we’ll see later make use of MSRs, as we’ll see soon.</p><h2 id="calling-system-calls-with-assembly-is-a-bad-idea">Calling system calls with assembly is a bad idea</h2><p>It’s not a great idea to call system calls by writing your own assembly code.</p><p>One big reason for this is that some system calls have additional code that runs in glibc before or after the system call runs.</p><p>In the examples below, we’ll be using the <code class="highlighter-rouge">exit</code> system call. It turns out that you can register functions to run when <code class="highlighter-rouge">exit</code> is called by a program by using <a href="http://man7.org/linux/man-pages/man3/atexit.3.html"><code class="highlighter-rouge">atexit</code></a>.</p><p>Those functions are called from glibc, not the kernel. So, if you write your own assembly to call <code class="highlighter-rouge">exit</code> as we show below, your registered handler functions won’t be executed since you are bypassing glibc.</p><p>Nevertheless, manually making system calls with assembly is a good learning experience.</p><h1 id="legacy-system-calls">Legacy system calls</h1><div class="button-container callout"><div class="large-link-container"> <a href="https://packagecloud.io/?utm_campaign=cmkt&amp;utm_medium=callout&amp;utm_source=/eng/2016/04/05/the-definitive-guide-to-linux-system-calls&amp;utm_term=Create%20a%20package%20repository%20in%20less%20than%2010%20seconds,%20free." id="signup-banner-link"></a></div><p>Create a package repository in less than 10 seconds, free.</p><div class="sign-up-button" data-landing-page="/" data-callout-text="Create a package repository in less than 10 seconds, free." data-source="/eng/2016/04/05/the-definitive-guide-to-linux-system-calls"> <a href="https://packagecloud.io/?utm_campaign=cmkt&amp;utm_medium=callout&amp;utm_source=/eng/2016/04/05/the-definitive-guide-to-linux-system-calls&amp;utm_term=Create%20a%20package%20repository%20in%20less%20than%2010%20seconds,%20free." id="signup-banner-link"> <button class="anim-btn btn btn-primary btn-default">Sign up!</button> </a></div></div><p>Using our prerequisite knowledge we know two things:</p><ol><li>We know that we can trigger the kernel to execute by generating a software interrupt.</li><li>We can generate a software interrupt with the <code class="highlighter-rouge">int</code> assembly instruction.</li></ol><p>Combining these two concepts leads us to the legacy system call interface on Linux.</p><p>The
 Linux kernel sets aside a specific software interrupt number that can 
be used by user space programs to enter the kernel and execute a system 
call.</p><p>The Linux kernel registers an interrupt handler named <code class="highlighter-rouge">ia32_syscall</code> for the interrupt number: 128 (0x80). Let’s take a look at the code that actually does this.</p><p>From the <code class="highlighter-rouge">trap_init</code> function in the kernel 3.13.0 source in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/traps.c#L770"><code class="highlighter-rouge">arch/x86/kernel/traps.c</code></a>:</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="n">__init</span> <span class="nf">trap_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="cm">/* ..... other code ... */</span>

        <span class="n">set_system_intr_gate</span><span class="p">(</span><span class="n">IA32_SYSCALL_VECTOR</span><span class="p">,</span> <span class="n">ia32_syscall</span><span class="p">);</span></code></pre></figure><p>Where <code class="highlighter-rouge">IA32_SYSCALL_VECTOR</code> is a defined as <code class="highlighter-rouge">0x80</code> in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/traps.c#L770"><code class="highlighter-rouge">arch/x86/include/asm/irq_vectors.h</code></a>.</p><p>But,
 if the kernel reserves a single software interrupt that userland 
programs can raise to trigger the kernel, how does the kernel know which
 of the many system calls it should execute?</p><p>The userland program is expected to put the system call number in the <code class="highlighter-rouge">eax</code> register. The arguments for the syscall itself are to be placed in the remaining general purpose registers.</p><p>One place this is documented is in a comment in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L378-L397"><code class="highlighter-rouge">arch/x86/ia32/ia32entry.S</code></a>:</p><figure class="highlight"><pre><code class="language-c" data-lang="c"> <span class="o">*</span> <span class="n">Emulated</span> <span class="n">IA32</span> <span class="n">system</span> <span class="n">calls</span> <span class="n">via</span> <span class="kt">int</span> <span class="mh">0x80</span><span class="p">.</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="n">Arguments</span><span class="o">:</span>
 <span class="o">*</span> <span class="o">%</span><span class="n">eax</span> <span class="n">System</span> <span class="n">call</span> <span class="n">number</span><span class="p">.</span>
 <span class="o">*</span> <span class="o">%</span><span class="n">ebx</span> <span class="n">Arg1</span>
 <span class="o">*</span> <span class="o">%</span><span class="n">ecx</span> <span class="n">Arg2</span>
 <span class="o">*</span> <span class="o">%</span><span class="n">edx</span> <span class="n">Arg3</span>
 <span class="o">*</span> <span class="o">%</span><span class="n">esi</span> <span class="n">Arg4</span>
 <span class="o">*</span> <span class="o">%</span><span class="n">edi</span> <span class="n">Arg5</span>
 <span class="o">*</span> <span class="o">%</span><span class="n">ebp</span> <span class="n">Arg6</span>    <span class="p">[</span><span class="n">note</span><span class="o">:</span> <span class="n">not</span> <span class="n">saved</span> <span class="n">in</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">frame</span><span class="p">,</span> <span class="n">should</span> <span class="n">not</span> <span class="n">be</span> <span class="n">touched</span><span class="p">]</span>
 <span class="o">*</span></code></pre></figure><p>Now that we know how 
to make a system call and where the arguments should live, let’s try to 
make one by writing some inline assembly.</p><h2 id="using-legacy-system-calls-with-your-own-assembly">Using legacy system calls with your own assembly</h2><p>To
 make a legacy system call, you can write a small bit of inline 
assembly. While this is interesting from a learning perspective, I 
encourage readers to never make system calls by crafting their own 
assembly.</p><p>In this example, we’ll try calling the <code class="highlighter-rouge">exit</code> system call, which takes a single argument: the exit status.</p><p>First, we need to find the system call number for <code class="highlighter-rouge">exit</code>.
 The Linux kernel includes a file which lists each system call in a 
table. This file is processed by various scripts at build time to 
generate header files which can be used by user programs.</p><p>Let’s look at the table found in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/syscalls/syscall_32.tbl"><code class="highlighter-rouge">arch/x86/syscalls/syscall_32.tbl</code></a>:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 i386  exit      sys_exit
</code></pre></div></div><p>The <code class="highlighter-rouge">exit</code> syscall is number <code class="highlighter-rouge">1</code>. According to the interface described above, we just need to move the syscall number into the <code class="highlighter-rouge">eax</code> register and the first argument (the exit status) into <code class="highlighter-rouge">ebx</code>.</p><p>Here’s a piece of C code with some inline assembly that does this. Let’s set the exit status to “42”:</p><p>(This
 example can be simplified, but I thought it would be interesting to 
make it a bit more wordy than necessary so that anyone who hasn’t seen 
GCC inline assembly before can use this as an example or reference.)</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">syscall_nr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>

  <span class="n">asm</span> <span class="p">(</span><span class="s">"movl %0, %%eax</span><span class="se">\n</span><span class="s">"</span>
             <span class="s">"movl %1, %%ebx</span><span class="se">\n</span><span class="s">"</span>
       <span class="s">"int $0x80"</span>
    <span class="o">:</span> <span class="cm">/* output parameters, we aren't outputting anything, no none */</span>
      <span class="cm">/* (none) */</span>
    <span class="o">:</span> <span class="cm">/* input parameters mapped to %0 and %1, repsectively */</span>
      <span class="s">"m"</span> <span class="p">(</span><span class="n">syscall_nr</span><span class="p">),</span> <span class="s">"m"</span> <span class="p">(</span><span class="n">exit_status</span><span class="p">)</span>
    <span class="o">:</span> <span class="cm">/* registers that we are "clobbering", unneeded since we are calling exit */</span>
      <span class="s">"eax"</span><span class="p">,</span> <span class="s">"ebx"</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><p>Next, compile, execute, and check the exit status:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>gcc <span class="nt">-o</span> <span class="nb">test </span>test.c
<span class="nv">$ </span>./test
<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
42</code></pre></figure><p>Success! We called the <code class="highlighter-rouge">exit</code> system call using the legacy system call method by raising a software interrupt.</p><h2 id="kernel-side-int-0x80-entry-point">Kernel-side: <code class="highlighter-rouge">int $0x80</code> entry point</h2><p>So
 now that we’ve seen how to trigger a system call from a userland 
program, let’s see how the kernel uses the system call number to execute
 the system call code.</p><p>Recall from the previous section that the kernel registered a syscall handler function called <code class="highlighter-rouge">ia32_syscall</code>.</p><p>This function is implemented in assembly in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L426"><code class="highlighter-rouge">arch/x86/ia32/ia32entry.S</code></a> and we can see several things happening in this function, the most important of which is the call to the actual syscall itself:</p><figure class="highlight"><pre><code class="language-asm" data-lang="asm">ia32_do_call:
        IA32_ARG_FIXUP
        call *ia32_sys_call_table(,%rax,8) # xxx: rip relative</code></pre></figure><p><code class="highlighter-rouge">IA32_ARG_FIXUP</code> is a macro which rearranges the legacy arguments so that they may be properly understood by the current system call layer.</p><p>The <code class="highlighter-rouge">ia32_sys_call_table</code> identifier refers to a table which is defined in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/syscall_ia32.c#L18-L25"><code class="highlighter-rouge">arch/x86/ia32/syscall_ia32.c</code></a>. Note the <code class="highlighter-rouge">#include</code> line toward the end of the code:</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">const</span> <span class="n">sys_call_ptr_t</span> <span class="n">ia32_sys_call_table</span><span class="p">[</span><span class="n">__NR_ia32_syscall_max</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="cm">/*
         * Smells like a compiler bug -- it doesn't work
         * when the &amp; below is removed.
         */</span>
        <span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">__NR_ia32_syscall_max</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">compat_ni_syscall</span><span class="p">,</span>
<span class="cp">#include &lt;asm/syscalls_32.h&gt;
</span><span class="p">};</span></code></pre></figure><p>Recall earlier we saw the syscall table defined in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/syscalls/syscall_32.tbl"><code class="highlighter-rouge">arch/x86/syscalls/syscall_32.tbl</code></a>.</p><p>There are a few scripts which run at compile time which take this table and generate the <code class="highlighter-rouge">syscalls_32.h</code> file from it. The generated header file is comprised of valid C code, which is simply inserted with the <code class="highlighter-rouge">#include</code> shown above to fill in <code class="highlighter-rouge">ia32_sys_call_table</code> with function addresses indexed by system call number.</p><p>And this is how you enter the kernel via a legacy system call.</p><h2 id="returning-from-a-legacy-system-call-with-iret">Returning from a legacy system call with <code class="highlighter-rouge">iret</code></h2><p>We’ve
 seen how to enter the kernel with a software interrupt, but how does 
the kernel return back to the user program and drop the privilege level 
after it has finished running?</p><p>If we turn to the (warning: large PDF) <a href="ftp://download.intel.com/design/processor/manuals/253668.pdf">Intel Software Developer’s Manual</a> we can find a helpful diagram that illustrates how the program stack will be arranged when a privilege level change occurs.</p><p>Let’s take a look:</p><p><img src="The%20Definitive%20Guide%20to%20Linux%20System%20Calls%20-%20Packagecloud%20Blog_files/isr_stack.png" alt="Screenshot of the Stack Usage on Transfers to Interrupt and Exception-Handling Routines"></p><p>When execution is transferred to the kernel function <code class="highlighter-rouge">ia32_syscall</code>
 via the execution of a software interrupt from a user program, a 
privilege level change occurs. The result is that the stack when <code class="highlighter-rouge">ia32_syscall</code> is entered will look like the diagram above.</p><p>This
 means that the return address and the CPU flags which encode the 
privilege level (and other stuff), and more are all saved on the program
 stack before <code class="highlighter-rouge">ia32_syscall</code> executes.</p><p>So,
 in order to resume execution the kernel just needs to copy these values
 from the program stack back into the registers where they belong and 
execution will resume back in userland.</p><p>OK, so how do you do that?</p><p>There’s a few ways to do that, but one of the easiest ways is to the use the <code class="highlighter-rouge">iret</code> instruction.</p><p>The Intel instruction set manual explains that the <code class="highlighter-rouge">iret</code> instruction pops the return address and saved register values from the stack in the order they were prepared:</p><blockquote><p>As
 with a real-address mode interrupt return, the IRET instruction pops 
the return instruction pointer, return code segment selector, and EFLAGS
 image from the stack to the EIP, CS, and EFLAGS registers, 
respectively, and then resumes execution of the interrupted program or 
procedure.</p></blockquote><p>Finding this code in the Linux kernel is a
 bit difficult as it is hidden beneath several macros and there is 
extensive care taken to deal with things like signals and ptrace system 
call exit tracking.</p><p>Eventually all the macros in the assembly stubs in the kernel reveal the <code class="highlighter-rouge">iret</code> which returns from a system call back to a user program.</p><p>From <code class="highlighter-rouge">irq_return</code> in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L1042-L1043"><code class="highlighter-rouge">arch/x86/kernel/entry_64.S</code></a>:</p><figure class="highlight"><pre><code class="language-asm" data-lang="asm">irq_return:
  INTERRUPT_RETURN</code></pre></figure><p>Where <code class="highlighter-rouge">INTERRUPT_RETURN</code> is defined in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/asm/irqflags.h#L132"><code class="highlighter-rouge">arch/x86/include/asm/irqflags.h</code></a> as <code class="highlighter-rouge">iretq</code>.</p><p>And now you know how legacy system calls work.</p><h1 id="fast-system-calls">Fast system calls</h1><p>The
 legacy method seems pretty reasonable, but there are newer ways to 
trigger a system call which don’t involve a software interrupt and are <a href="https://lkml.org/lkml/2002/12/9/13">much faster</a> than using a software interrupt.</p><p>Each
 of the two faster methods is comprised of two instructions. One to 
enter the kernel and one to leave. Both methods are described in the 
Intel CPU documentation as “Fast System Call”.</p><p>Unfortunately, 
Intel and AMD implementations have some disagreement on which method is 
valid when a CPU is in 32bit or 64bit mode.</p><p>In order to maximize compatibility across both Intel and AMD CPUs:</p><ul><li>On 32bit systems use: <code class="highlighter-rouge">sysenter</code> and <code class="highlighter-rouge">sysexit</code>.</li><li>On 64bit systems use: <code class="highlighter-rouge">syscall</code> and <code class="highlighter-rouge">sysret</code>.</li></ul><div class="button-container callout"><div class="large-link-container"> <a href="https://packagecloud.io/?utm_campaign=cmkt&amp;utm_medium=callout&amp;utm_source=/eng/2016/04/05/the-definitive-guide-to-linux-system-calls&amp;utm_term=Create%20a%20package%20repository%20in%20less%20than%2010%20seconds,%20free." id="signup-banner-link"></a></div><p>Create a package repository in less than 10 seconds, free.</p><div class="sign-up-button" data-landing-page="/" data-callout-text="Create a package repository in less than 10 seconds, free." data-source="/eng/2016/04/05/the-definitive-guide-to-linux-system-calls"> <a href="https://packagecloud.io/?utm_campaign=cmkt&amp;utm_medium=callout&amp;utm_source=/eng/2016/04/05/the-definitive-guide-to-linux-system-calls&amp;utm_term=Create%20a%20package%20repository%20in%20less%20than%2010%20seconds,%20free." id="signup-banner-link"> <button class="anim-btn btn btn-primary btn-default">Sign up!</button> </a></div></div><h2 id="32-bit-fast-system-calls">32-bit fast system calls</h2><h3 id="sysentersysexit"><code class="highlighter-rouge">sysenter</code>/<code class="highlighter-rouge">sysexit</code></h3><p>Using <code class="highlighter-rouge">sysenter</code>
 to make a system call is more complicated than using the legacy 
interrupt method and involves more coordination between the user program
 (via <code class="highlighter-rouge">glibc</code>) and the kernel.</p><p>Let’s
 take it one step at a time and sort out the details. First, let’s see 
what the documentation in the Intel Instruction Set Reference (warning 
very large <a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-2b-manual.pdf">PDF</a>) says about the <code class="highlighter-rouge">sysenter</code> and how to use it.</p><p>Let’s take a look:</p><blockquote><p>Prior
 to executing the SYSENTER instruction, software must specify the 
privilege level 0 code segment and code entry point, and the privilege 
level 0 stack segment and stack pointer by writing values to the 
following MSRs:</p><p>• IA32_SYSENTER_CS (MSR address 174H) — The lower 
16 bits of this MSR are the segment selector for the privilege level 0 
code segment. This value is also used to determine the segment selector 
of the privilege level 0 stack segment (see the Operation section). This
 value cannot indicate a null selector.</p><p>• IA32_SYSENTER_EIP (MSR 
address 176H) — The value of this MSR is loaded into RIP (thus, this 
value references the first instruction of the selected operating 
procedure or routine). In protected mode, only bits 31:0 are loaded.</p><p>•
 IA32_SYSENTER_ESP (MSR address 175H) — The value of this MSR is loaded 
into RSP (thus, this value contains the stack pointer for the privilege 
level 0 stack). This value cannot represent a non-canonical address. In 
protected mode, only bits 31:0 are loaded.</p></blockquote><p>In other words: in order for the kernel to receive incoming system calls with <code class="highlighter-rouge">sysenter</code>, the kernel must set 3 Model Specific Registers (MSRs). The most interesting MSR in our case is <code class="highlighter-rouge">IA32_SYSENTER_EIP</code>
 (which has the address 0x176). This MSR is where the kernel should 
specify the address of the function that will execute when a <code class="highlighter-rouge">sysenter</code> instruction is executed by a user program.</p><p>We can find the code in the Linux kernel which writes to the MSR in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vdso32-setup.c#L240"><code class="highlighter-rouge">arch/x86/vdso/vdso32-setup.c</code></a>:</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">enable_sep_cpu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="cm">/* ... other code ... */</span>

        <span class="n">wrmsr</span><span class="p">(</span><span class="n">MSR_IA32_SYSENTER_EIP</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">ia32_sysenter_target</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span></code></pre></figure><p>Where <code class="highlighter-rouge">MSR_IA32_SYSENTER_EIP</code> is defined as a <code class="highlighter-rouge">0x00000176</code> <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/uapi/asm/msr-index.h#L54"><code class="highlighter-rouge">arch/x86/include/uapi/asm/msr-index.h</code></a>.</p><p>Much like the legacy software interrupt syscalls, there is a defined convention for making system calls with <code class="highlighter-rouge">sysenter</code>.</p><p>One place this is documented is in a comment in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L99-L117"><code class="highlighter-rouge">arch/x86/ia32/ia32entry.S</code></a>:</p><figure class="highlight"><pre><code class="language-c" data-lang="c"> <span class="o">*</span> <span class="mi">32</span><span class="n">bit</span> <span class="n">SYSENTER</span> <span class="n">instruction</span> <span class="n">entry</span><span class="p">.</span>
 <span class="o">*</span>
 <span class="o">*</span> <span class="n">Arguments</span><span class="o">:</span>
 <span class="o">*</span> <span class="o">%</span><span class="n">eax</span> <span class="n">System</span> <span class="n">call</span> <span class="n">number</span><span class="p">.</span>
 <span class="o">*</span> <span class="o">%</span><span class="n">ebx</span> <span class="n">Arg1</span>
 <span class="o">*</span> <span class="o">%</span><span class="n">ecx</span> <span class="n">Arg2</span>
 <span class="o">*</span> <span class="o">%</span><span class="n">edx</span> <span class="n">Arg3</span>
 <span class="o">*</span> <span class="o">%</span><span class="n">esi</span> <span class="n">Arg4</span>
 <span class="o">*</span> <span class="o">%</span><span class="n">edi</span> <span class="n">Arg5</span>
 <span class="o">*</span> <span class="o">%</span><span class="n">ebp</span> <span class="n">user</span> <span class="n">stack</span>
 <span class="o">*</span> <span class="mi">0</span><span class="p">(</span><span class="o">%</span><span class="n">ebp</span><span class="p">)</span> <span class="n">Arg6</span></code></pre></figure><p>Recall
 that the legacy system call method includes a mechanism for returning 
back to the userland program which was interrupted: the <code class="highlighter-rouge">iret</code> instruction.</p><p>Capturing the logic needed to make <code class="highlighter-rouge">sysenter</code> work properly is complicated because unlike software interrupts, <code class="highlighter-rouge">sysenter</code> does not store the return address.</p><p>How, exactly, the kernel does this and other bookkeeping prior to executing a <code class="highlighter-rouge">sysenter</code> instruction can change over time (and it has changed, as you will see in the Bugs section below).</p><p>In order to protect against future changes, user programs are intended to use a function called <code class="highlighter-rouge">__kernel_vsyscall</code> which is implemented in the kernel, but mapped into each user process when the process is started.</p><p>This is a bit odd; it’s code that comes with the kernel, but runs in userland.</p><p>It turns out that <code class="highlighter-rouge">__kernel_vsyscall</code>
 is part of something called a virtual Dynamic Shared Object (vDSO) 
which exists to allow programs to execute kernel code in userland.</p><p>We’ll examine what the vDSO is, what it does, and how it works in depth later.</p><p>For now, let’s examine the <code class="highlighter-rouge">__kernel_vsyscall</code> internals.</p><h3 id="__kernel_vsyscall-internals"><code class="highlighter-rouge">__kernel_vsyscall</code> internals</h3><p>The <code class="highlighter-rouge">__kernel_vsyscall</code> function that encapulates the <code class="highlighter-rouge">sysenter</code> calling convention can be found in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vdso32/sysenter.S#L31-L40"><code class="highlighter-rouge">arch/x86/vdso/vdso32/sysenter.S</code></a>:</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="nl">__kernel_vsyscall:</span>
<span class="p">.</span><span class="n">LSTART_vsyscall</span><span class="o">:</span>
        <span class="n">push</span> <span class="o">%</span><span class="n">ecx</span>
<span class="p">.</span><span class="n">Lpush_ecx</span><span class="o">:</span>
        <span class="n">push</span> <span class="o">%</span><span class="n">edx</span>
<span class="p">.</span><span class="n">Lpush_edx</span><span class="o">:</span>
        <span class="n">push</span> <span class="o">%</span><span class="n">ebp</span>
<span class="p">.</span><span class="n">Lenter_kernel</span><span class="o">:</span>
        <span class="n">movl</span> <span class="o">%</span><span class="n">esp</span><span class="p">,</span><span class="o">%</span><span class="n">ebp</span>
        <span class="n">sysenter</span></code></pre></figure><p><code class="highlighter-rouge">__kernel_vsyscall</code>
 is part of a Dynamic Shared Object (also known as a shared library) how
 does a user program locate the address of that function at runtime?</p><p>The address of the <code class="highlighter-rouge">__kernel_vsyscall</code> function is written into an <a href="https://www.gnu.org/software/libc/manual/html_node/Auxiliary-Vector.html">ELF auxilliary vector</a> where a user program or library (typically <code class="highlighter-rouge">glibc</code>) can find it and use it.</p><p>There are a few methods for searching ELF auxilliary vectors:</p><ol><li>By using <a href="http://man7.org/linux/man-pages/man3/getauxval.3.html"><code class="highlighter-rouge">getauxval</code></a> with the <code class="highlighter-rouge">AT_SYSINFO</code> argument.</li><li>By iterating to the end of the environment variables and parsing them from memory.</li></ol><p>Option 1 is the simplest option, but does not exist on <code class="highlighter-rouge">glibc</code> prior to 2.16. The example code shown below illustrates option 2.</p><p>As we can see in the code above, <code class="highlighter-rouge">__kernel_vsyscall</code> does some bookkeeping before executing <code class="highlighter-rouge">sysenter</code>.</p><p>So, all we need to do to manually enter the kernel with <code class="highlighter-rouge">sysenter</code> is:</p><ul><li>Search the ELF auxilliary vectors for <code class="highlighter-rouge">AT_SYSINFO</code> where the address of <code class="highlighter-rouge">__kernel_vsyscall</code> is written.</li><li>Put the system call number and arguments into the registers as we would normally for legacy system calls</li><li>Call the <code class="highlighter-rouge">__kernel_vsyscall</code> function</li></ul><p>You should absolutely never write your own <code class="highlighter-rouge">sysenter</code> wrapper function as the convention the kernel uses to enter and leave system calls with <code class="highlighter-rouge">sysenter</code> can change and your code will break.</p><p>You should <em>always</em> start a <code class="highlighter-rouge">sysenter</code> system call by calling through <code class="highlighter-rouge">__kernel_vsyscall</code>.</p><p>So, lets do that.</p><h3 id="using-sysenter-system-calls-with-your-own-assembly">Using <code class="highlighter-rouge">sysenter</code> system calls with your own assembly</h3><p>Keeping with our legacy system call example from earlier, we’ll call <code class="highlighter-rouge">exit</code> with an exit status of <code class="highlighter-rouge">42</code>.</p><p>The <code class="highlighter-rouge">exit</code> syscall is number <code class="highlighter-rouge">1</code>. According to the interface described above, we just need to move the syscall number into the <code class="highlighter-rouge">eax</code> register and the first argument (the exit status) into <code class="highlighter-rouge">ebx</code>.</p><p>(This
 example can be simplified, but I thought it would be interesting to 
make it a bit more wordy than necessary so that anyone who hasn’t seen 
GCC inline assembly before can use this as an example or reference.)</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;stdlib.h&gt;
#include &lt;elf.h&gt;
</span>
<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[],</span> <span class="kt">char</span><span class="o">*</span> <span class="n">envp</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">syscall_nr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
  <span class="n">Elf32_auxv_t</span> <span class="o">*</span><span class="n">auxv</span><span class="p">;</span>

  <span class="cm">/* auxilliary vectors are located after the end of the environment
   * variables
   *
   * check this helpful diagram: https://static.lwn.net/images/2012/auxvec.png
   */</span>
  <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">envp</span><span class="o">++</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="cm">/* envp is now pointed at the auxilliary vectors, since we've iterated
   * through the environment variables.
   */</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">auxv</span> <span class="o">=</span> <span class="p">(</span><span class="n">Elf32_auxv_t</span> <span class="o">*</span><span class="p">)</span><span class="n">envp</span><span class="p">;</span> <span class="n">auxv</span><span class="o">-&gt;</span><span class="n">a_type</span> <span class="o">!=</span> <span class="n">AT_NULL</span><span class="p">;</span> <span class="n">auxv</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">auxv</span><span class="o">-&gt;</span><span class="n">a_type</span> <span class="o">==</span> <span class="n">AT_SYSINFO</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="cm">/* NOTE: in glibc 2.16 and higher you can replace the above code with
   * a call to getauxval(3):  getauxval(AT_SYSINFO)
   */</span>

  <span class="n">asm</span><span class="p">(</span>
      <span class="s">"movl %0,  %%eax    </span><span class="se">\n</span><span class="s">"</span>
      <span class="s">"movl %1, %%ebx    </span><span class="se">\n</span><span class="s">"</span>
      <span class="s">"call *%2          </span><span class="se">\n</span><span class="s">"</span>
      <span class="o">:</span> <span class="cm">/* output parameters, we aren't outputting anything, no none */</span>
        <span class="cm">/* (none) */</span>
      <span class="o">:</span> <span class="cm">/* input parameters mapped to %0 and %1, repsectively */</span>
        <span class="s">"m"</span> <span class="p">(</span><span class="n">syscall_nr</span><span class="p">),</span> <span class="s">"m"</span> <span class="p">(</span><span class="n">exit_status</span><span class="p">),</span> <span class="s">"m"</span> <span class="p">(</span><span class="n">auxv</span><span class="o">-&gt;</span><span class="n">a_un</span><span class="p">.</span><span class="n">a_val</span><span class="p">)</span>
      <span class="o">:</span> <span class="cm">/* registers that we are "clobbering", unneeded since we are calling exit */</span>
        <span class="s">"eax"</span><span class="p">,</span> <span class="s">"ebx"</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><p>Next, compile, execute, and check the exit status:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>gcc <span class="nt">-m32</span> <span class="nt">-o</span> <span class="nb">test </span>test.c
<span class="nv">$ </span>./test
<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
42</code></pre></figure><p>Success! We called the <code class="highlighter-rouge">exit</code> system call using the legacy sysenter method without raising a software interrupt.</p><h3 id="kernel-side-sysenter-entry-point">Kernel-side: <code class="highlighter-rouge">sysenter</code> entry point</h3><p>So now that we’ve seen how to trigger a system call from a userland program with <code class="highlighter-rouge">sysenter</code> via <code class="highlighter-rouge">__kernel_vsyscall</code>, let’s see how the kernel uses the system call number to execute the system call code.</p><p>Recall from the previous section that the kernel registered a syscall handler function called <code class="highlighter-rouge">ia32_sysenter_target</code>.</p><p>This function is implemented in assembly in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L162-L163"><code class="highlighter-rouge">arch/x86/ia32/ia32entry.S</code></a>. Let’s take a look at where the value in the eax register is used to execute the system call:</p><figure class="highlight"><pre><code class="language-asm" data-lang="asm">sysenter_dispatch:
        call    *ia32_sys_call_table(,%rax,8)</code></pre></figure><p>This is identical code as we saw in the legacy system call mode: a table named <code class="highlighter-rouge">ia32_sys_call_table</code> which is indexed into with the system call number.</p><p>After all the needed bookkeeping is done both the legacy system call model and the <code class="highlighter-rouge">sysenter</code> system call model use the same mechanism and system call table for dispatching system calls.</p><p>Refer to the <a href="#kernel-side-int-0x80-entry-point"><code class="highlighter-rouge">int $0x80</code> entry point section</a> to learn where the <code class="highlighter-rouge">ia32_sys_call_table</code> is defined and how it is constructed.</p><p>And this is how you enter the kernel via a <code class="highlighter-rouge">sysenter</code> system call.</p><h3 id="returning-from-a-sysenter-system-call-with-sysexit">Returning from a <code class="highlighter-rouge">sysenter</code> system call with <code class="highlighter-rouge">sysexit</code></h3><p>The kernel can use the <code class="highlighter-rouge">sysexit</code> instruction to resume execution back to the user program.</p><p>Using this instruction is not as straight forward as using <code class="highlighter-rouge">iret</code>. The caller is expected to put the address to return to into the <code class="highlighter-rouge">rdx</code> register, and to put the pointer to the program stack to use in the <code class="highlighter-rouge">rcx</code> register.</p><p>This
 means that your software must compute the address where execution 
should be resumed, preserve that value, and restore it prior to calling <code class="highlighter-rouge">sysexit</code>.</p><p>We can find the code which does this in: <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L169-L185"><code class="highlighter-rouge">arch/x86/ia32/ia32entry.S</code></a>:</p><figure class="highlight"><pre><code class="language-asm" data-lang="asm">sysexit_from_sys_call:
        andl    $~TS_COMPAT,TI_status+THREAD_INFO(%rsp,RIP-ARGOFFSET)
        /* clear IF, that popfq doesn't enable interrupts early */
        andl  $~0x200,EFLAGS-R11(%rsp)
        movl    RIP-R11(%rsp),%edx              /* User %eip */
        CFI_REGISTER rip,rdx
        RESTORE_ARGS 0,24,0,0,0,0
        xorq    %r8,%r8
        xorq    %r9,%r9
        xorq    %r10,%r10
        xorq    %r11,%r11
        popfq_cfi
        /*CFI_RESTORE rflags*/
        popq_cfi %rcx                           /* User %esp */
        CFI_REGISTER rsp,rcx
        TRACE_IRQS_ON
        ENABLE_INTERRUPTS_SYSEXIT32</code></pre></figure><p><code class="highlighter-rouge">ENABLE_INTERRUPTS_SYSEXIT32</code> is a macro which is defined in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/asm/irqflags.h#L139-L143"><code class="highlighter-rouge">arch/x86/include/asm/irqflags.h</code></a> which contains the <code class="highlighter-rouge">sysexit</code> instruction.</p><p>And now you know how 32-bit fast system calls work.</p><h2 id="64-bit-fast-system-calls">64-bit fast system calls</h2><p>Next up on our journey are 64-bit fast system calls. These system calls use the instructions <code class="highlighter-rouge">syscall</code> and <code class="highlighter-rouge">sysret</code> to enter and return from a system call, respectively.</p><h3 id="syscallsysret"><code class="highlighter-rouge">syscall</code>/<code class="highlighter-rouge">sysret</code></h3><div class="button-container callout"><div class="large-link-container"> <a href="https://packagecloud.io/?utm_campaign=cmkt&amp;utm_medium=callout&amp;utm_source=/eng/2016/04/05/the-definitive-guide-to-linux-system-calls&amp;utm_term=Create%20a%20package%20repository%20in%20less%20than%2010%20seconds,%20free." id="signup-banner-link"></a></div><p>Create a package repository in less than 10 seconds, free.</p><div class="sign-up-button" data-landing-page="/" data-callout-text="Create a package repository in less than 10 seconds, free." data-source="/eng/2016/04/05/the-definitive-guide-to-linux-system-calls"> <a href="https://packagecloud.io/?utm_campaign=cmkt&amp;utm_medium=callout&amp;utm_source=/eng/2016/04/05/the-definitive-guide-to-linux-system-calls&amp;utm_term=Create%20a%20package%20repository%20in%20less%20than%2010%20seconds,%20free." id="signup-banner-link"> <button class="anim-btn btn btn-primary btn-default">Sign up!</button> </a></div></div><p>The documentation in the Intel Instruction Set Reference (very large <a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-2b-manual.pdf">PDF</a>) explains how the <code class="highlighter-rouge">syscall</code> instruction works:</p><blockquote><p>SYSCALL
 invokes an OS system-call handler at privilege level 0. It does so by 
loading RIP from the IA32_LSTAR MSR (after saving the address of the 
instruction following SYSCALL into RCX).</p></blockquote><p>In other 
words: for the kernel to receive incoming system calls, it must register
 the address of the code that will execute when a system call occurs by 
writing its address to the <code class="highlighter-rouge">IA32_LSTAR</code> MSR.</p><p>We can find that code in the kernel in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/cpu/common.c#L1128"><code class="highlighter-rouge">arch/x86/kernel/cpu/common.c</code></a>:</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">syscall_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="cm">/* ... other code ... */</span>
        <span class="n">wrmsrl</span><span class="p">(</span><span class="n">MSR_LSTAR</span><span class="p">,</span> <span class="n">system_call</span><span class="p">);</span></code></pre></figure><p>Where <code class="highlighter-rouge">MSR_LSTAR</code> is defined as <code class="highlighter-rouge">0xc0000082</code> in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/uapi/asm/msr-index.h#L9"><code class="highlighter-rouge">arch/x86/include/uapi/asm/msr-index.h</code></a>.</p><p>Much like the legacy software interrupt syscalls, there is a defined convention for making system calls with <code class="highlighter-rouge">syscall</code>.</p><p>The userland program is expected to put the system call number to be in the <code class="highlighter-rouge">rax</code> register. The arguments to the syscall are expected to be placed in a subset of the general purpose registers.</p><p>This is documented in the <a href="http://www.x86-64.org/documentation/abi.pdf">x86-64 ABI</a> in section A.2.1:</p><blockquote><ol><li>User-level
 applications use as integer registers for passing the sequence %rdi, 
%rsi, %rdx, %rcx, %r8 and %r9. The kernel interface uses %rdi, %rsi, 
%rdx, %r10, %r8 and %r9.</li><li>A system-call is done via the syscall instruction. The kernel destroys registers %rcx and %r11.</li><li>The number of the syscall has to be passed in register %rax.</li><li>System-calls are limited to six arguments,no argument is passed directly on the stack.</li><li>Returning
 from the syscall, register %rax contains the result of the system-call.
 A value in the range between -4095 and -1 indicates an error, it is 
-errno.</li><li>Only values of class INTEGER or class MEMORY are passed to the kernel.</li></ol></blockquote><p>This is also documented in a comment in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L569-L591"><code class="highlighter-rouge">arch/x86/kernel/entry_64.S</code></a>.</p><p>Now
 that we know how to make a system call and where the arguments should 
live, let’s try to make one by writing some inline assembly.</p><h3 id="using-syscall-system-calls-with-your-own-assembly">Using <code class="highlighter-rouge">syscall</code> system calls with your own assembly</h3><p>Building
 on the previous example, let’s build a small C program with inline 
assembly which executes the exit system call passing the exit status of 
42.</p><p>First, we need to find the system call number for <code class="highlighter-rouge">exit</code>. In this case we need to read the table found in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/syscalls/syscall_64.tbl#L69"><code class="highlighter-rouge">arch/x86/syscalls/syscall_64.tbl</code></a>:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>60      common  exit                    sys_exit
</code></pre></div></div><p>The <code class="highlighter-rouge">exit</code> syscall is number <code class="highlighter-rouge">60</code>. According to the interface described above, we just need to move <code class="highlighter-rouge">60</code> into the <code class="highlighter-rouge">rax</code> register and the first argument (the exit status) into <code class="highlighter-rouge">rdi</code>.</p><p>Here’s
 a piece of C code with some inline assembly that does this. Like the 
previous example, this example is more wordy than necessary in the 
interest of clarity:</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">syscall_nr</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>

  <span class="n">asm</span> <span class="p">(</span><span class="s">"movq %0, %%rax</span><span class="se">\n</span><span class="s">"</span>
       <span class="s">"movq %1, %%rdi</span><span class="se">\n</span><span class="s">"</span>
       <span class="s">"syscall"</span>
    <span class="o">:</span> <span class="cm">/* output parameters, we aren't outputting anything, no none */</span>
      <span class="cm">/* (none) */</span>
    <span class="o">:</span> <span class="cm">/* input parameters mapped to %0 and %1, repsectively */</span>
      <span class="s">"m"</span> <span class="p">(</span><span class="n">syscall_nr</span><span class="p">),</span> <span class="s">"m"</span> <span class="p">(</span><span class="n">exit_status</span><span class="p">)</span>
    <span class="o">:</span> <span class="cm">/* registers that we are "clobbering", unneeded since we are calling exit */</span>
      <span class="s">"rax"</span><span class="p">,</span> <span class="s">"rdi"</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><p>Next, compile, execute, and check the exit status:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>gcc <span class="nt">-o</span> <span class="nb">test </span>test.c
<span class="nv">$ </span>./test
<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
42</code></pre></figure><p>Success! We called the <code class="highlighter-rouge">exit</code> system call using the <code class="highlighter-rouge">syscall</code> system call method. We avoided raising a software interrupt and (if we were timing a micro-benchmark) it executes much faster.</p><h3 id="kernel-side-syscall-entry-point">Kernel-side: syscall entry point</h3><p>Now
 we’ve seen how to trigger a system call from a userland program, let’s 
see how the kernel uses the system call number to execute the system 
call code.</p><p>Recall from the previous section we saw the address of a function named <code class="highlighter-rouge">system_call</code> get written to the <code class="highlighter-rouge">LSTAR</code> MSR.</p><p>Let’s take a look at the code for this function and see how it uses <code class="highlighter-rouge">rax</code> to actually hand off execution to the system call, from <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L629"><code class="highlighter-rouge">arch/x86/kernel/entry_64.S</code></a>:</p><figure class="highlight"><pre><code class="language-asm" data-lang="asm">        call *sys_call_table(,%rax,8)  # XXX:    rip relative</code></pre></figure><p>Much like the legacy system call method, <code class="highlighter-rouge">sys_call_table</code> is a table defined in a C file that uses <code class="highlighter-rouge">#include</code> to pull in C code generated by a script.</p><p>From <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/syscall_64.c#L25-L32"><code class="highlighter-rouge">arch/x86/kernel/syscall_64.c</code></a>, note the <code class="highlighter-rouge">#include</code> at the bottom:</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">asmlinkage</span> <span class="k">const</span> <span class="n">sys_call_ptr_t</span> <span class="n">sys_call_table</span><span class="p">[</span><span class="n">__NR_syscall_max</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="cm">/*
         * Smells like a compiler bug -- it doesn't work
         * when the &amp; below is removed.
         */</span>
        <span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">__NR_syscall_max</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sys_ni_syscall</span><span class="p">,</span>
<span class="cp">#include &lt;asm/syscalls_64.h&gt;
</span><span class="p">};</span></code></pre></figure><p>Earlier we saw the syscall table defined in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/syscalls/syscall_64.tbl"><code class="highlighter-rouge">arch/x86/syscalls/syscall_64.tbl</code></a>. Exactly like the legacy interrupt mode, a script runs at kernel compile time and generates the <code class="highlighter-rouge">syscalls_64.h</code> file from the table in <code class="highlighter-rouge">syscall_64.tbl</code>.</p><p>The code above simply includes the generated C code producing an array of function pointers indexed by system call number.</p><p>And this is how you enter the kernel via a <code class="highlighter-rouge">syscall</code> system call.</p><h3 id="returning-from-a-syscall-system-call-with-sysret">Returning from a <code class="highlighter-rouge">syscall</code> system call with <code class="highlighter-rouge">sysret</code></h3><p>The kernel can use the <code class="highlighter-rouge">sysret</code> instruction to resume execution back to where execution left off when the user program used <code class="highlighter-rouge">syscall</code>.</p><p><code class="highlighter-rouge">sysret</code> is simpler than <code class="highlighter-rouge">sysexit</code> because the address to where execution should be resume is copied into the <code class="highlighter-rouge">rcx</code> register when <code class="highlighter-rouge">syscall</code> is used.</p><p>As long as you preserve that value somewhere and restore it to <code class="highlighter-rouge">rcx</code> before calling <code class="highlighter-rouge">sysret</code>, execution will resume where it left off before the call to <code class="highlighter-rouge">syscall</code>.</p><p>This is convenient because <code class="highlighter-rouge">sysenter</code> requires that you compute this address yourself in addition to clobbering an additional register.</p><p>We can find the code which does this in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L650-L655"><code class="highlighter-rouge">arch/x86/kernel/entry_64.S</code></a>:</p><figure class="highlight"><pre><code class="language-asm" data-lang="asm">movq RIP-ARGOFFSET(%rsp),%rcx
CFI_REGISTER    rip,rcx
RESTORE_ARGS 1,-ARG_SKIP,0
/*CFI_REGISTER  rflags,r11*/
movq    PER_CPU_VAR(old_rsp), %rsp
USERGS_SYSRET64</code></pre></figure><p><code class="highlighter-rouge">USERGS_SYSRET64</code> is a macro which is defined in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/asm/irqflags.h#L133-L135"><code class="highlighter-rouge">arch/x86/include/asm/irqflags.h</code></a> which contains the <code class="highlighter-rouge">sysret</code> instruction.</p><p>And now you know how 64-bit fast system calls work.</p><h1 id="calling-a-syscall-semi-manually-with-syscall2">Calling a syscall semi-manually with syscall(2)</h1><p>Great, we’ve seen how to call system calls manually by crafting assembly for a few different system call methods.</p><p>Usually,
 you don’t need to write your own assembly. Wrapper functions are 
provided by glibc that handle all of the assembly code for you.</p><p>There are some system calls, however, for which no glibc wrapper exists. One example of a system call like this is <code class="highlighter-rouge">futex</code>, the fast userspace locking system call.</p><p>But, wait, why does <a href="http://man7.org/linux/man-pages/man7/futex.7.html#NOTES">no system call wrapper exist for <code class="highlighter-rouge">futex</code></a>?</p><p><code class="highlighter-rouge">futex</code> is intended only to be called by libraries, not application code, and thus in order to call <code class="highlighter-rouge">futex</code> you must do it by:</p><ol><li>Generating assembly stubs for every platform you want to support</li><li>Using the <code class="highlighter-rouge">syscall</code> wrapper provided by glibc</li></ol><p>If
 you find yourself in the situation of needing to call a system call for
 which no wrapper exists, you should definitely choose option 2: use the
 function <code class="highlighter-rouge">syscall</code> from glibc.</p><p>Let’s use <code class="highlighter-rouge">syscall</code> from glibc to call <code class="highlighter-rouge">exit</code> with exit status of <code class="highlighter-rouge">42</code>:</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;unistd.h&gt;
</span>
<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">syscall_nr</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">exit_status</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>

  <span class="n">syscall</span><span class="p">(</span><span class="n">syscall_nr</span><span class="p">,</span> <span class="n">exit_status</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><p>Next, compile, execute, and check the exit status:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>gcc <span class="nt">-o</span> <span class="nb">test </span>test.c
<span class="nv">$ </span>./test
<span class="nv">$ </span><span class="nb">echo</span> <span class="nv">$?</span>
42</code></pre></figure><p>Success! We called the <code class="highlighter-rouge">exit</code> system call using the <code class="highlighter-rouge">syscall</code> wrapper from glibc.</p><h2 id="glibc-syscall-wrapper-internals">glibc <code class="highlighter-rouge">syscall</code> wrapper internals</h2><div class="button-container callout"><div class="large-link-container"> <a href="https://packagecloud.io/?utm_campaign=cmkt&amp;utm_medium=callout&amp;utm_source=/eng/2016/04/05/the-definitive-guide-to-linux-system-calls&amp;utm_term=Create%20a%20package%20repository%20in%20less%20than%2010%20seconds,%20free." id="signup-banner-link"></a></div><p>Create a package repository in less than 10 seconds, free.</p><div class="sign-up-button" data-landing-page="/" data-callout-text="Create a package repository in less than 10 seconds, free." data-source="/eng/2016/04/05/the-definitive-guide-to-linux-system-calls"> <a href="https://packagecloud.io/?utm_campaign=cmkt&amp;utm_medium=callout&amp;utm_source=/eng/2016/04/05/the-definitive-guide-to-linux-system-calls&amp;utm_term=Create%20a%20package%20repository%20in%20less%20than%2010%20seconds,%20free." id="signup-banner-link"> <button class="anim-btn btn btn-primary btn-default">Sign up!</button> </a></div></div><p>Let’s take a look at the <code class="highlighter-rouge">syscall</code> wrapper function we used in the previous example to see how it works in glibc.</p><p>From <a href="https://github.molgen.mpg.de/git-mirror/glibc/blob/glibc-2.15/sysdeps/unix/sysv/linux/x86_64/syscall.S#L24-L42"><code class="highlighter-rouge">sysdeps/unix/sysv/linux/x86_64/syscall.S</code></a>:</p><figure class="highlight"><pre><code class="language-asm" data-lang="asm">/* Usage: long syscall (syscall_number, arg1, arg2, arg3, arg4, arg5, arg6)
   We need to do some arg shifting, the syscall_number will be in
   rax.  */


        .text
ENTRY (syscall)
        movq %rdi, %rax         /* Syscall number -&gt; rax.  */
        movq %rsi, %rdi         /* shift arg1 - arg5.  */
        movq %rdx, %rsi
        movq %rcx, %rdx
        movq %r8, %r10
        movq %r9, %r8
        movq 8(%rsp),%r9        /* arg6 is on the stack.  */
        syscall                 /* Do the system call.  */
        cmpq $-4095, %rax       /* Check %rax for error.  */
        jae SYSCALL_ERROR_LABEL /* Jump to error handler if error.  */
L(pseudo_end):
        ret                     /* Return to caller.  */</code></pre></figure><p>Earlier we showed an excerpt from the x86_64 ABI document that describes both userland and kernel calling conventions.</p><p>This assembly stub is cool because it shows <em>both</em>
 calling conventions. The arguments passed into this function follow the
 userland calling convention, but are then moved to a different set of 
registers to obey the kernel calling convention prior to entering the 
kernel with <code class="highlighter-rouge">syscall</code>.</p><p>This is how the glibc syscall wrapper works when you use it to call system calls that do not come with a wrapper by default.</p><h1 id="virtual-system-calls">Virtual system calls</h1><p>We’ve
 now covered all the methods of making a system call by entering the 
kernel and shown how you can make those calls manually (or 
semi-manually) to transition the system from userland to the kernel.</p><p>What if programs could call certain system calls without entering the kernel at all?</p><p>That’s
 precisely why the Linux virtual Dynamic Shared Object (vDSO) exists. 
The Linux vDSO is a set of code that is part of the kernel, but is 
mapped into the address space of a user program to be run in userland.</p><p>The idea is that some system calls can be used without entering the kernel. One such call is: <code class="highlighter-rouge">gettimeofday</code>.</p><p>Programs calling the <code class="highlighter-rouge">gettimeofday</code> system call do not actually enter the kernel. They instead make a simple function call to a piece of code that was <em>provided</em> by the kernel, but is run in userland.</p><p>No software interrupt is raised, no complicated <code class="highlighter-rouge">sysenter</code> or <code class="highlighter-rouge">syscall</code> bookkeeping is required. <code class="highlighter-rouge">gettimeofday</code> is just a normal function call.</p><p>You can see the vDSO listed as the first entry when you use <code class="highlighter-rouge">ldd</code>:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>ldd <span class="sb">`</span>which bash<span class="sb">`</span>
  linux-vdso.so.1 <span class="o">=&gt;</span>  <span class="o">(</span>0x00007fff667ff000<span class="o">)</span>
  libtinfo.so.5 <span class="o">=&gt;</span> /lib/x86_64-linux-gnu/libtinfo.so.5 <span class="o">(</span>0x00007f623df7d000<span class="o">)</span>
  libdl.so.2 <span class="o">=&gt;</span> /lib/x86_64-linux-gnu/libdl.so.2 <span class="o">(</span>0x00007f623dd79000<span class="o">)</span>
  libc.so.6 <span class="o">=&gt;</span> /lib/x86_64-linux-gnu/libc.so.6 <span class="o">(</span>0x00007f623d9ba000<span class="o">)</span>
  /lib64/ld-linux-x86-64.so.2 <span class="o">(</span>0x00007f623e1ae000<span class="o">)</span></code></pre></figure><p>Let’s see how the vDSO is setup in the kernel.</p><div class="button-container callout"><div class="large-link-container"> <a href="https://packagecloud.io/?utm_campaign=cmkt&amp;utm_medium=callout&amp;utm_source=/eng/2016/04/05/the-definitive-guide-to-linux-system-calls&amp;utm_term=Create%20a%20package%20repository%20in%20less%20than%2010%20seconds,%20free." id="signup-banner-link"></a></div><p>Create a package repository in less than 10 seconds, free.</p><div class="sign-up-button" data-landing-page="/" data-callout-text="Create a package repository in less than 10 seconds, free." data-source="/eng/2016/04/05/the-definitive-guide-to-linux-system-calls"> <a href="https://packagecloud.io/?utm_campaign=cmkt&amp;utm_medium=callout&amp;utm_source=/eng/2016/04/05/the-definitive-guide-to-linux-system-calls&amp;utm_term=Create%20a%20package%20repository%20in%20less%20than%2010%20seconds,%20free." id="signup-banner-link"> <button class="anim-btn btn btn-primary btn-default">Sign up!</button> </a></div></div><h2 id="vdso-in-the-kernel">vDSO in the kernel</h2><p>You can find the vDSO source in <a href="https://github.com/torvalds/linux/tree/v3.13/arch/x86/vdso"><code class="highlighter-rouge">arch/x86/vdso/</code></a>. There are a few assembly and C source files along with a linker script.</p><p>The <a href="https://sourceware.org/binutils/docs/ld/Scripts.html">linker script</a> is a cool thing to take a look at.</p><p>From <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vdso.lds.S"><code class="highlighter-rouge">arch/x86/vdso/vdso.lds.S</code></a>:</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/*
 * This controls what userland symbols we export from the vDSO.
 */</span>
<span class="n">VERSION</span> <span class="p">{</span>
        <span class="n">LINUX_2</span><span class="p">.</span><span class="mi">6</span> <span class="p">{</span>
        <span class="n">global</span><span class="o">:</span>
                <span class="n">clock_gettime</span><span class="p">;</span>
                <span class="n">__vdso_clock_gettime</span><span class="p">;</span>
                <span class="n">gettimeofday</span><span class="p">;</span>
                <span class="n">__vdso_gettimeofday</span><span class="p">;</span>
                <span class="n">getcpu</span><span class="p">;</span>
                <span class="n">__vdso_getcpu</span><span class="p">;</span>
                <span class="n">time</span><span class="p">;</span>
                <span class="n">__vdso_time</span><span class="p">;</span>
        <span class="n">local</span><span class="o">:</span> <span class="o">*</span><span class="p">;</span>
        <span class="p">};</span>
<span class="p">}</span></code></pre></figure><p>Linker scripts are 
pretty useful, but not particularly very well known. This linker script 
arranges the symbols that are going to be exported in the vDSO.</p><p>We
 can see that vDSO exports 4 different functions, each with two names. 
You can find the source for these functions in the C files in this 
directory.</p><p>For example, the source for <code class="highlighter-rouge">gettimeofday</code> found in <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vclock_gettime.c#L281-L282"><code class="highlighter-rouge">arch/x86/vdso/vclock_gettime.c</code></a>:</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">gettimeofday</span><span class="p">(</span><span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timezone</span> <span class="o">*</span><span class="p">)</span>
        <span class="n">__attribute__</span><span class="p">((</span><span class="n">weak</span><span class="p">,</span> <span class="n">alias</span><span class="p">(</span><span class="s">"__vdso_gettimeofday"</span><span class="p">)));</span></code></pre></figure><p>This is defining <code class="highlighter-rouge">gettimeofday</code> to be a <a href="https://gcc.gnu.org/onlinedocs/gcc-4.3.5/gcc/Function-Attributes.html">weak alias</a> for <code class="highlighter-rouge">__vdso_gettimeofday</code>.</p><p>The <code class="highlighter-rouge">__vdso_gettimeofday</code> function <a href="https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vclock_gettime.c#L260-L280">in the same file</a> contains the actual source which will be executed <em>in user land</em> when a user program calls the <code class="highlighter-rouge">gettimeofday</code> system call.</p><h2 id="locating-the-vdso-in-memory">Locating the vDSO in memory</h2><p>Due to <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">address space layout randomization</a> the vDSO will be loaded at a random address when a program is started.</p><p>How can user programs find the vDSO if its loaded at a random address?</p><p>If you recall earlier when examining the <code class="highlighter-rouge">sysenter</code> system call method we saw that user programs should call <code class="highlighter-rouge">__kernel_vsyscall</code> instead of writing their own <code class="highlighter-rouge">sysenter</code> assembly code themselves.</p><p>This function is part of the vDSO, as well.</p><p>The sample code provided located <code class="highlighter-rouge">__kernel_vsyscall</code> by searching the <a href="https://www.gnu.org/software/libc/manual/html_node/Auxiliary-Vector.html">ELF auxilliary headers</a> to find a header with type <code class="highlighter-rouge">AT_SYSINFO</code> which contained the address of <code class="highlighter-rouge">__kernel_vsyscall</code>.</p><p>Similarly, to locate the vDSO, a user program can search for an ELF auxilliary header of type <code class="highlighter-rouge">AT_SYSINFO_EHDR</code>. It will contain the address of the start of the ELF header for the vDSO that was generated by a linker script.</p><p>In
 both cases, the kernel writes the address in to the ELF header when the
 program is loaded. That’s how the correct addresses always end up in <code class="highlighter-rouge">AT_SYSINFO_EHDR</code> and <code class="highlighter-rouge">AT_SYSINFO</code>.</p><p>Once that header is located, user programs can parse the ELF object (perhaps using <a href="http://www.mr511.de/software/english.html">libelf</a>) and call the functions in the ELF object as needed.</p><p>This is nice because this means that the vDSO can take advantage of some useful ELF features like <a href="https://www.akkadia.org/drepper/symbol-versioning">symbol versioning</a>.</p><p>An example of parsing and calling functions in the vDSO is provided in the kernel documentation in <a href="https://github.com/torvalds/linux/tree/v3.13/Documentation/vDSO"><code class="highlighter-rouge">Documentation/vDSO/</code></a>.</p><h2 id="vdso-in-glibc">vDSO in glibc</h2><p>Most of the time, people access the vDSO without knowing it because <code class="highlighter-rouge">glibc</code> abstracts this away from them by using the interface described in the previous section.</p><p>When a program is loaded, the <a href="http://man7.org/linux/man-pages/man8/ld.so.8.html">dynamic linker and loader</a> loads the DSOs that the program depends on, including the vDSO.</p><p><code class="highlighter-rouge">glibc</code>
 stores some data about the location of the vDSO when it parses the ELF 
headers of the program that is being loaded. It also includes short stub
 functions that will search the vDSO for a symbol name prior to making 
an actual system call.</p><p>For example, the <code class="highlighter-rouge">gettimeofday</code> function in <code class="highlighter-rouge">glibc</code>, from <a href="https://github.molgen.mpg.de/git-mirror/glibc/blob/glibc-2.15/sysdeps/unix/sysv/linux/x86_64/gettimeofday.c#L26-L37"><code class="highlighter-rouge">sysdeps/unix/sysv/linux/x86_64/gettimeofday.c</code></a>:</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="o">*</span><span class="n">gettimeofday_ifunc</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">__asm__</span> <span class="p">(</span><span class="s">"__gettimeofday"</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span>
<span class="nf">gettimeofday_ifunc</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">PREPARE_VERSION</span> <span class="p">(</span><span class="n">linux26</span><span class="p">,</span> <span class="s">"LINUX_2.6"</span><span class="p">,</span> <span class="mi">61765110</span><span class="p">);</span>

  <span class="cm">/* If the vDSO is not available we fall back on the old vsyscall.  */</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">_dl_vdso_vsym</span> <span class="p">(</span><span class="s">"gettimeofday"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">linux26</span><span class="p">)</span>
          <span class="o">?:</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">VSYSCALL_ADDR_vgettimeofday</span><span class="p">);</span>
<span class="p">}</span>
<span class="kr">__asm</span> <span class="p">(</span><span class="s">".type __gettimeofday, %gnu_indirect_function"</span><span class="p">);</span></code></pre></figure><p>This code in <code class="highlighter-rouge">glibc</code> searches the vDSO for the <code class="highlighter-rouge">gettimeofday</code> function and returns the address. This is wrapped up nicely with an <a href="http://willnewton.name/uncategorized/using-gnu-indirect-functions/">indirect function</a>.</p><p>That’s how programs calling <code class="highlighter-rouge">gettimeofday</code> pass through <code class="highlighter-rouge">glibc</code> and hit the vDSO all without switching into kernel mode, incurring a privilege level change, or raising a software interrupt.</p><p>And, that concludes the showcase of every single system call method available on Linux for 32-bit and 64-bit Intel and AMD CPUs.</p><h1 id="glibc-system-call-wrappers"><code class="highlighter-rouge">glibc</code> system call wrappers</h1><p>While we’re talking about system calls ;) it makes sense to briefly mention how <code class="highlighter-rouge">glibc</code> deals with system calls.</p><p>For many system calls, <code class="highlighter-rouge">glibc</code> simply needs a wrapper function where it moves arguments into the proper registers and then executes the <code class="highlighter-rouge">syscall</code> or <code class="highlighter-rouge">int $0x80</code> instructions, or calls <code class="highlighter-rouge">__kernel_vsyscall</code>.</p><p>It does this by using a series of tables defined in text files that are processed with scripts and output C code.</p><p>For example, the <a href="https://github.molgen.mpg.de/git-mirror/glibc/blob/glibc-2.15/sysdeps/unix/syscalls.list"><code class="highlighter-rouge">sysdeps/unix/syscalls.list</code></a> file describes some common system calls:</p><figure class="highlight"><pre><code class="language-sh" data-lang="sh">access          -       access          i:si    __access        access
acct            -       acct            i:S     acct
chdir           -       chdir           i:s     __chdir         chdir
chmod           -       chmod           i:si    __chmod         chmod</code></pre></figure><p>To learn more about each column, check the comments in the script which processes this file: <a href="https://github.molgen.mpg.de/git-mirror/glibc/blob/glibc-2.15/sysdeps/unix/make-syscalls.sh"><code class="highlighter-rouge">sysdeps/unix/make-syscalls.sh</code></a>.</p><p>More complex system calls, like <code class="highlighter-rouge">exit</code>
 which invokes handlers have actual implementations in C or assembly 
code and will not be found in a templated text file like this.</p><p>Future blog posts will explore the implementation in <code class="highlighter-rouge">glibc</code> and the linux kernel for interesting system calls.</p><h1 id="interesting-syscall-related-bugs">Interesting syscall related bugs</h1><div class="button-container callout"><div class="large-link-container"> <a href="https://packagecloud.io/?utm_campaign=cmkt&amp;utm_medium=callout&amp;utm_source=/eng/2016/04/05/the-definitive-guide-to-linux-system-calls&amp;utm_term=Create%20a%20package%20repository%20in%20less%20than%2010%20seconds,%20free." id="signup-banner-link"></a></div><p>Create a package repository in less than 10 seconds, free.</p><div class="sign-up-button" data-landing-page="/" data-callout-text="Create a package repository in less than 10 seconds, free." data-source="/eng/2016/04/05/the-definitive-guide-to-linux-system-calls"> <a href="https://packagecloud.io/?utm_campaign=cmkt&amp;utm_medium=callout&amp;utm_source=/eng/2016/04/05/the-definitive-guide-to-linux-system-calls&amp;utm_term=Create%20a%20package%20repository%20in%20less%20than%2010%20seconds,%20free." id="signup-banner-link"> <button class="anim-btn btn btn-primary btn-default">Sign up!</button> </a></div></div><p>It would be unfortunate not to take this opportunity to mention two fabulous bugs related to system calls in Linux.</p><p>So, let’s take a look!</p><h2 id="cve-2010-3301">CVE-2010-3301</h2><p><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=2010-3301">This security exploit</a> allows local users to gain root access.</p><p>The cause is a small bug in the assembly code which allows user programs to make legacy system calls on x86-64 systems.</p><p>The exploit code is pretty clever: it generates a region of memory with <code class="highlighter-rouge">mmap</code> at a particular address and uses an integer overflow to cause this code:</p><p>(Remember this code from the legacy interrupts section above?)</p><figure class="highlight"><pre><code class="language-asm" data-lang="asm">call *ia32_sys_call_table(,%rax,8)</code></pre></figure><p>to hand execution off to an arbitrary address which runs as kernel code and can escalate the running process to root.</p><h2 id="android-sysenter-abi-breakage">Android <code class="highlighter-rouge">sysenter</code> ABI breakage</h2><p>Remember the part about not hardcoding the <code class="highlighter-rouge">sysenter</code> ABI in your application code?</p><p>Unfortunately, the android-x86 folks made this mistake. The kernel ABI changed and suddenly android-x86 stopped working.</p><p>The kernel folks ended up restoring the old <code class="highlighter-rouge">sysenter</code> ABI to avoid breaking the Android devices in the wild with stale hardcoded <code class="highlighter-rouge">sysenter</code> sequences.</p><p><a href="http://git.kernel.org/cgit/linux/kernel/git/tip/tip.git/commit/?id=30bfa7b3488bfb1bb75c9f50a5fcac1832970c60">Here’s the fix</a> that was added to the Linux kernel. You can find a link to the offending commit in the android source in the commit message.</p><p>Remember: never write your own <code class="highlighter-rouge">sysenter</code> assembly code. If you have to implement it directly for some reason, use a piece of code like the example above and go through <code class="highlighter-rouge">__kernel_vsyscall</code> at the very least.</p><h1 id="conclusion">Conclusion</h1><p>The
 system call infrastructure in the Linux kernel is incredibly complex. 
There are many different methods for making system calls each with their
 own advantages and disadvantages.</p><p>Calling system calls by 
crafting your own assembly is generally a bad idea as the ABI may break 
underneath you. Your kernel and libc implementation will (probably) 
choose the fastest method for making system calls on your system.</p><p>If you can’t use the <code class="highlighter-rouge">glibc</code> provided wrappers (or if one doesn’t exist), you should at the very least use the <code class="highlighter-rouge">syscall</code> wrapper function, or try to go through the vDSO provided <code class="highlighter-rouge">__kernel_vsyscall</code>.</p><p>Stay tuned for future blog posts investigating individual system calls and their implementations.</p><h1 id="related-posts">Related Posts</h1><p>If you enjoyed this post, you may also enjoy other low level technical posts such as:</p><ul><li><a href="https://blog.packagecloud.io/eng/2016/02/29/how-does-strace-work/">How does <code class="highlighter-rouge">strace</code> work?</a></li><li><a href="https://blog.packagecloud.io/eng/2016/03/14/how-does-ltrace-work/">How does <code class="highlighter-rouge">ltrace</code> work?</a></li><li><a href="https://blog.packagecloud.io/eng/2016/03/21/apt-hash-sum-mismatch/">APT Hash sum mismatch</a></li><li><a href="https://blog.packagecloud.io/eng/2014/10/28/howto-gpg-sign-verify-deb-packages-apt-repositories/">HOWTO: GPG sign and verify deb packages and APT repositories</a></li><li><a href="https://blog.packagecloud.io/eng/2014/11/24/howto-gpg-sign-verify-rpm-packages-yum-repositories/">HOWTO: GPG sign and verify RPM packages and yum repositories</a></li></ul></article><section class="sharing col-md-12"><h4>Share this post:</h4> <a class="resp-sharing-button__link" href="https://facebook.com/sharer/sharer.php?u=https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/" target="_blank" aria-label=""><div class="resp-sharing-button resp-sharing-button--facebook resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid"> <svg version="1.1" x="0px" y="0px" width="24px" height="24px" viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve"> <g><path d="M18.768,7.465H14.5V5.56c0-0.896,0.594-1.105,1.012-1.105s2.988,0,2.988,0V0.513L14.171,0.5C10.244,0.5,9.5,3.438,9.5,5.32 v2.145h-3v4h3c0,5.212,0,12,0,12h5c0,0,0-6.85,0-12h3.851L18.768,7.465z"></path> </g> </svg></div></div></a>  <a class="resp-sharing-button__link" href="https://twitter.com/intent/tweet/?text=The%20Definitive%20Guide%20to%20Linux%20System%20Calls&amp;url=https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/" target="_blank" aria-label=""><div class="resp-sharing-button resp-sharing-button--twitter resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid"> <svg version="1.1" x="0px" y="0px" width="24px" height="24px" viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve"> <g><path d="M23.444,4.834c-0.814,0.363-1.5,0.375-2.228,0.016c0.938-0.562,0.981-0.957,1.32-2.019c-0.878,0.521-1.851,0.9-2.886,1.104 C18.823,3.053,17.642,2.5,16.335,2.5c-2.51,0-4.544,2.036-4.544,4.544c0,0.356,0.04,0.703,0.117,1.036 C8.132,7.891,4.783,6.082,2.542,3.332C2.151,4.003,1.927,4.784,1.927,5.617c0,1.577,0.803,2.967,2.021,3.782 C3.203,9.375,2.503,9.171,1.891,8.831C1.89,8.85,1.89,8.868,1.89,8.888c0,2.202,1.566,4.038,3.646,4.456 c-0.666,0.181-1.368,0.209-2.053,0.079c0.579,1.804,2.257,3.118,4.245,3.155C5.783,18.102,3.372,18.737,1,18.459 C3.012,19.748,5.399,20.5,7.966,20.5c8.358,0,12.928-6.924,12.928-12.929c0-0.198-0.003-0.393-0.012-0.588 C21.769,6.343,22.835,5.746,23.444,4.834z"></path> </g> </svg></div></div></a>  <a class="resp-sharing-button__link" href="https://plus.google.com/share?url=https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/" target="_blank" aria-label=""><div class="resp-sharing-button resp-sharing-button--google resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid"> <svg version="1.1" x="0px" y="0px" width="24px" height="24px" viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve"> <g><path d="M11.366,12.928c-0.729-0.516-1.393-1.273-1.404-1.505c0-0.425,0.038-0.627,0.988-1.368 c1.229-0.962,1.906-2.228,1.906-3.564c0-1.212-0.37-2.289-1.001-3.044h0.488c0.102,0,0.2-0.033,0.282-0.091l1.364-0.989 c0.169-0.121,0.24-0.338,0.176-0.536C14.102,1.635,13.918,1.5,13.709,1.5H7.608c-0.667,0-1.345,0.118-2.011,0.347 c-2.225,0.766-3.778,2.66-3.778,4.605c0,2.755,2.134,4.845,4.987,4.91c-0.056,0.22-0.084,0.434-0.084,0.645 c0,0.425,0.108,0.827,0.33,1.216c-0.026,0-0.051,0-0.079,0c-2.72,0-5.175,1.334-6.107,3.32C0.623,17.06,0.5,17.582,0.5,18.098 c0,0.501,0.129,0.984,0.382,1.438c0.585,1.046,1.843,1.861,3.544,2.289c0.877,0.223,1.82,0.335,2.8,0.335 c0.88,0,1.718-0.114,2.494-0.338c2.419-0.702,3.981-2.482,3.981-4.538C13.701,15.312,13.068,14.132,11.366,12.928z M3.66,17.443 c0-1.435,1.823-2.693,3.899-2.693h0.057c0.451,0.005,0.892,0.072,1.309,0.2c0.142,0.098,0.28,0.192,0.412,0.282 c0.962,0.656,1.597,1.088,1.774,1.783c0.041,0.175,0.063,0.35,0.063,0.519c0,1.787-1.333,2.693-3.961,2.693 C5.221,20.225,3.66,19.002,3.66,17.443z M5.551,3.89c0.324-0.371,0.75-0.566,1.227-0.566l0.055,0 c1.349,0.041,2.639,1.543,2.876,3.349c0.133,1.013-0.092,1.964-0.601,2.544C8.782,9.589,8.363,9.783,7.866,9.783H7.865H7.844 c-1.321-0.04-2.639-1.6-2.875-3.405C4.836,5.37,5.049,4.462,5.551,3.89z"></path><polygon points="23.5,9.5 20.5,9.5 20.5,6.5 18.5,6.5 18.5,9.5 15.5,9.5 15.5,11.5 18.5,11.5 18.5,14.5 20.5,14.5 20.5,11.5 23.5,11.5 "></polygon> </g> </svg></div></div></a>  <a class="resp-sharing-button__link" href="https://www.tumblr.com/widgets/share/tool?posttype=link&amp;title=The%20Definitive%20Guide%20to%20Linux%20System%20Calls&amp;caption=The%20Definitive%20Guide%20to%20Linux%20System%20Calls&amp;content=https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/&amp;canonicalUrl=https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/&amp;shareSource=tumblr_share_button" target="_blank" aria-label=""><div class="resp-sharing-button resp-sharing-button--tumblr resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid"> <svg version="1.1" x="0px" y="0px" width="24px" height="24px" viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve"> <g><path d="M13.5,0.5v5h5v4h-5v5.515c0,5.028,3.52,4.427,6,2.798v4.433c-6.728,3.172-12-0.064-12-4.255V9.5h-3V6.668 c0.903-0.293,2.245-0.714,2.889-1.261c0.646-0.551,1.162-1.208,1.551-1.976C9.331,2.664,9.6,1.686,9.746,0.5H13.5z"></path> </g> </svg></div></div></a>  <a class="resp-sharing-button__link" href="mailto:?subject=The%20Definitive%20Guide%20to%20Linux%20System%20Calls&amp;body=https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/" target="_self" aria-label=""><div class="resp-sharing-button resp-sharing-button--email resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid"> <svg version="1.1" x="0px" y="0px" width="24px" height="24px" viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve"><path d="M22,4H2C0.897,4,0,4.897,0,6v12c0,1.103,0.897,2,2,2h20c1.103,0,2-0.897,2-2V6C24,4.897,23.103,4,22,4z M7.248,14.434 l-3.5,2C3.67,16.479,3.584,16.5,3.5,16.5c-0.174,0-0.342-0.09-0.435-0.252c-0.137-0.239-0.054-0.545,0.186-0.682l3.5-2 c0.24-0.137,0.545-0.054,0.682,0.186C7.571,13.992,7.488,14.297,7.248,14.434z M12,14.5c-0.094,0-0.189-0.026-0.271-0.08l-8.5-5.5 C2.997,8.77,2.93,8.46,3.081,8.229c0.15-0.23,0.459-0.298,0.691-0.147L12,13.405l8.229-5.324c0.232-0.15,0.542-0.084,0.691,0.147 c0.15,0.232,0.083,0.542-0.148,0.691l-8.5,5.5C12.189,14.474,12.095,14.5,12,14.5z M20.934,16.248 C20.842,16.41,20.673,16.5,20.5,16.5c-0.084,0-0.169-0.021-0.248-0.065l-3.5-2c-0.24-0.137-0.323-0.442-0.186-0.682 s0.443-0.322,0.682-0.186l3.5,2C20.988,15.703,21.071,16.009,20.934,16.248z"></path> </svg></div></div></a>  <a class="resp-sharing-button__link" href="https://reddit.com/submit/?url=https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/" target="_blank" aria-label=""><div class="resp-sharing-button resp-sharing-button--reddit resp-sharing-button--small"><div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid"> <svg version="1.1" x="0px" y="0px" width="24px" height="24px" viewBox="0 0 24 24" enable-background="new 0 0 24 24" xml:space="preserve"><path d="M24,11.5c0-1.654-1.346-3-3-3c-0.964,0-1.863,0.476-2.422,1.241c-1.639-1.006-3.747-1.64-6.064-1.723 c0.064-1.11,0.4-3.049,1.508-3.686c0.72-0.414,1.733-0.249,3.01,0.478C17.189,6.317,18.452,7.5,20,7.5c1.654,0,3-1.346,3-3 s-1.346-3-3-3c-1.382,0-2.536,0.944-2.883,2.217C15.688,3,14.479,2.915,13.521,3.466c-1.642,0.945-1.951,3.477-2.008,4.551 C9.186,8.096,7.067,8.731,5.422,9.741C4.863,8.976,3.964,8.5,3,8.5c-1.654,0-3,1.346-3,3c0,1.319,0.836,2.443,2.047,2.844 C2.019,14.56,2,14.778,2,15c0,3.86,4.486,7,10,7s10-3.14,10-7c0-0.222-0.019-0.441-0.048-0.658C23.148,13.938,24,12.795,24,11.5z M2.286,13.366C1.522,13.077,1,12.351,1,11.5c0-1.103,0.897-2,2-2c0.635,0,1.217,0.318,1.59,0.816 C3.488,11.17,2.683,12.211,2.286,13.366z M6,13.5c0-1.103,0.897-2,2-2s2,0.897,2,2c0,1.103-0.897,2-2,2S6,14.603,6,13.5z M15.787,18.314c-1.063,0.612-2.407,0.949-3.787,0.949c-1.387,0-2.737-0.34-3.803-0.958c-0.239-0.139-0.321-0.444-0.182-0.683 c0.139-0.24,0.444-0.322,0.683-0.182c1.828,1.059,4.758,1.062,6.59,0.008c0.239-0.138,0.545-0.055,0.683,0.184 C16.108,17.871,16.026,18.177,15.787,18.314z M16,15.5c-1.103,0-2-0.897-2-2c0-1.103,0.897-2,2-2s2,0.897,2,2 C18,14.603,17.103,15.5,16,15.5z M21.713,13.365c-0.397-1.155-1.201-2.195-2.303-3.048C19.784,9.818,20.366,9.5,21,9.5 c1.103,0,2,0.897,2,2C23,12.335,22.468,13.073,21.713,13.365z"></path> </svg></div></div></a></section></div></section></div></div></div><div id="footer-container" class="footer-container"><footer><ul class="footer-group"><li class="header">Features</li><li><span><a class="footer-link" href="https://packagecloud.io/docs#travis">Travis CI</a></span></li><li><span><a class="footer-link" href="https://packagecloud.io/docs#jenkins">Jenkins</a></span></li><li><span><a class="footer-link" href="https://packagecloud.io/docs#buildkite">Buildkite</a></span></li><li><span><a class="footer-link" href="https://packagecloud.io/docs#public_private_repos">Public Package Repository</a></span></li><li><span><a class="footer-link" href="https://packagecloud.io/docs#public_private_repos">Private Package Repository</a></span></li><li><span><a class="footer-link" href="https://packagecloud.io/docs#security_features">GPG Signatures</a></span></li></ul><ul class="footer-group"><li class="header">Info</li><li><span><a class="footer-link" href="https://packagecloud.io/pricing">Pricing</a></span></li><li><span><a class="footer-link" href="https://packagecloud.io/l/npm-registry?utm_campaign=cmkt&amp;utm_medium=footer&amp;utm_source=blog">Private NPM registry</a></span></li><li><span><a class="footer-link" href="https://packagecloud.io/l/apt-repository?utm_campaign=cmkt&amp;utm_medium=footer&amp;utm_source=blog">Private DEB repository</a></span></li><li><span><a class="footer-link" href="https://packagecloud.io/l/yum-repository?utm_campaign=cmkt&amp;utm_medium=footer&amp;utm_source=blog">Private RPM repository</a></span></li><li><span><a class="footer-link" href="https://packagecloud.io/l/rubygem-repository?utm_campaign=cmkt&amp;utm_medium=footer&amp;utm_source=blog">Private RubyGem server</a></span></li><li><span><a class="footer-link" href="https://packagecloud.io/l/pypi-repository?utm_campaign=cmkt&amp;utm_medium=footer&amp;utm_source=blog">Private PyPI server</a></span></li><li><span><a class="footer-link" href="https://packagecloud.io/l/maven-repository?utm_campaign=cmkt&amp;utm_medium=footer&amp;utm_source=blog">Private Maven repository</a></span></li></ul><ul class="footer-group"><li class="header">HOWTOs</li><li><span><a class="footer-link" href="https://blog.packagecloud.io/tag/npm-howto">NPM/NodeJS HOWTO</a></span></li><li><span><a class="footer-link" href="https://blog.packagecloud.io/tag/maven-howto">Maven HOWTO</a></span></li><li><span><a class="footer-link" href="https://blog.packagecloud.io/tag/java-howto">Java <br>HOWTO</a></span></li><li><span><a class="footer-link" href="https://blog.packagecloud.io/tag/debian-howto">Debian HOWTO</a></span></li><li><span><a class="footer-link" href="https://blog.packagecloud.io/tag/rpm-howto">RPM HOWTO</a></span></li><li><span><a class="footer-link" href="https://blog.packagecloud.io/tag/rubygem-howto">RubyGem HOWTO</a></span></li><li><span><a class="footer-link" href="https://blog.packagecloud.io/tag/python-howto">Python HOWTO</a></span></li><li><span><a class="footer-link" href="https://blog.packagecloud.io/tag/linux-howto">Linux HOWTO</a></span></li></ul><ul class="footer-group"><li class="header">Guides</li><li><span><a class="footer-link" href="https://blog.packagecloud.io/tag/maven-guide">Maven Guide</a></span></li><li><span><a class="footer-link" href="https://blog.packagecloud.io/tag/debian-guide">Debian Guide</a></span></li><li><span><a class="footer-link" href="https://blog.packagecloud.io/tag/rpm-guide">RPM Guide</a></span></li><li><span><a class="footer-link" href="https://blog.packagecloud.io/tag/rubygem-guide">RubyGem Guide</a></span></li><li><span><a class="footer-link" href="https://blog.packagecloud.io/tag/python-guide">Python Guide</a></span></li><li><span><a class="footer-link" href="https://blog.packagecloud.io/tag/linux">Linux Guide</a></span></li></ul><ul class="footer-group"><li class="header">Docs</li><li><span><a class="footer-link" href="https://packagecloud.io/docs">General Docs</a></span></li><li><span><a class="footer-link" href="https://packagecloud.io/docs/api">API Docs</a></span></li><li><span><a class="footer-link" href="https://packagecloud.io/docs#cli">Command Line Interface</a></span></li></ul><ul class="footer-group"><li class="header">Community</li><li><span><a class="footer-link" href="https://packagecloud.io/blog">Blog</a></span></li><li><span class="hosted"><a class="footer-link" href="http://bit.ly/packagecloud-users">Slack</a></span></li><li><span class="hosted"><a class="footer-link " href="http://www.packagecloudstatus.io/">Status</a></span></li><li><span class="hosted"><a class="footer-link" href="https://packagecloud.io/contact">Contact</a></span></li></ul><ul class="footer-group"><li class="header">Legal</li><li><span><a class="footer-link" href="https://packagecloud.io/legal/tos">Terms of Service</a></span></li><li><span><a class="footer-link" href="https://packagecloud.io/legal/privacy">Privacy Policy</a></span></li></ul></footer></div><link type="text/css" rel="stylesheet" href="The%20Definitive%20Guide%20to%20Linux%20System%20Calls%20-%20Packagecloud%20Blog_files/application.css"><link href="The%20Definitive%20Guide%20to%20Linux%20System%20Calls%20-%20Packagecloud%20Blog_files/css.css" rel="stylesheet" type="text/css"><link href="The%20Definitive%20Guide%20to%20Linux%20System%20Calls%20-%20Packagecloud%20Blog_files/css_002.css" rel="stylesheet" type="text/css"> <script src="The%20Definitive%20Guide%20to%20Linux%20System%20Calls%20-%20Packagecloud%20Blog_files/jquery.js"></script> <script type="text/javascript" src="The%20Definitive%20Guide%20to%20Linux%20System%20Calls%20-%20Packagecloud%20Blog_files/jquery-scrollspy.js"></script> <script type="text/javascript" src="The%20Definitive%20Guide%20to%20Linux%20System%20Calls%20-%20Packagecloud%20Blog_files/callouts.js"></script> <script type="text/javascript" src="The%20Definitive%20Guide%20to%20Linux%20System%20Calls%20-%20Packagecloud%20Blog_files/callout-visibility.js"></script> <script type="text/javascript" src="The%20Definitive%20Guide%20to%20Linux%20System%20Calls%20-%20Packagecloud%20Blog_files/backtop.js"></script> <script type="text/javascript" src="The%20Definitive%20Guide%20to%20Linux%20System%20Calls%20-%20Packagecloud%20Blog_files/newsletter-slidein.js"></script> <script type="text/javascript" src="The%20Definitive%20Guide%20to%20Linux%20System%20Calls%20-%20Packagecloud%20Blog_files/picturefill.js"></script> <script type="text/javascript" src="The%20Definitive%20Guide%20to%20Linux%20System%20Calls%20-%20Packagecloud%20Blog_files/nav.js"></script>
</body></html>